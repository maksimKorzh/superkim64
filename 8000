
; 64tass Turbo Assembler Macro V1.56.2625 listing file
; 64tass -L 8000 -i -o supermon64-8000.prg "-DORG=\$8000" supermon64.asm
; Fri Jun 24 18:52:59 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$8000					ORG=$8000

;******  Processing input file: supermon64.asm

=$c1					TMP0    = $C1               ; used to return input, often holds end address
=$c3					TMP2    = $C3               ; usually holds start address
=$90					SATUS   = $90               ; kernal i/o status word
=$b7					FNLEN   = $B7               ; length of current filename
=$b9					SADD    = $B9               ; current secondary address (official name SA)
=$ba					FA      = $BA               ; current device number
=$bb					FNADR   = $BB               ; pointer to current filename
=$c6					NDX     = $C6               ; number of characters in keyboard buffer
=$0277					KEYD    = $0277             ; keyboard buffer
=$0316					BKVEC   = $0316             ; BRK instruction vector (official name CBINV)
>0100					ACMD    .FILL 1             ; addressing command
>0101					LENGTH  .FILL 1             ; length of operand
>0102					MNEMW   .FILL 3             ; 3 letter mnemonic buffer
>0105					SAVX    .FILL 1             ; 1 byte temp storage, often to save X register
>0106					OPCODE  .FILL 1             ; current opcode for assembler/disassembler
>0107					UPFLG   .FILL 1             ; flag: count up (bit 7 clear) or down (bit 7 set)
>0108					DIGCNT  .FILL 1             ; digit count
>0109					INDIG   .FILL 1             ; numeric value of single digit
>010a					NUMBIT  .FILL 1             ; numeric base of input
>010b					STASH   .FILL 2             ; 2-byte temp storage
>010d					U0AA0   .FILL 10            ; work buffer
=$0117					U0AAE   =*                  ; end of work buffer
>0117					STAGE   .FILL 30            ; staging buffer for filename, search, etc.
=$0135					ESTAGE  =*                  ; end of staging buffer
>0200					INBUFF  .FILL 40            ; 40-character input buffer
=$0228					ENDIN   =*                  ; end of input buffer
>0228					PCH     .FILL 1             ; program counter high byte
>0229					PCL     .FILL 1             ; program counter low byte
>022a					SR      .FILL 1             ; status register
>022b					ACC     .FILL 1             ; accumulator
>022c					XR      .FILL 1             ; X register
>022d					YR      .FILL 1             ; Y register
>022e					SP      .FILL 1             ; stack pointer
>022f					STORE   .FILL 2             ; 2-byte temp storage
>0231					CHRPNT  .FILL 1             ; current position in input buffer
>0232					SAVY    .FILL 1             ; temp storage, often to save Y register
>0233					U9F     .FILL 1             ; index into assembler work buffer
=$ff90					SETMSG  = $FF90             ; set kernel message control flag
=$ff93					SECOND  = $FF93             ; set secondary address after LISTEN
=$ff96					TKSA    = $FF96             ; send secondary address after TALK
=$ffb1					LISTEN  = $FFB1             ; command serial bus device to LISTEN
=$ffb4					TALK    = $FFB4             ; command serial bus device to TALK
=$ffba					SETLFS  = $FFBA             ; set logical file parameters
=$ffbd					SETNAM  = $FFBD             ; set filename
=$ffa5					ACPTR   = $FFA5             ; input byte from serial bus
=$ffa8					CIOUT   = $FFA8             ; output byte to serial bus
=$ffab					UNTLK   = $FFAB             ; command serial bus device to UNTALK
=$ffae					UNLSN   = $FFAE             ; command serial bus device to UNLISTEN
=$ffc6					CHKIN   = $FFC6             ; define input channel
=$ffcc					CLRCHN  = $FFCC             ; restore default devices
=$1e5a					INPUT   = $1E5A             ; input a character (official name CHRIN)
=$1ea0					CHROUT  = $1EA0             ; output a character
=$ffd5					LOAD    = $FFD5             ; load from device
=$ffd8					SAVE    = $FFD8             ; save to device
=$ffe1					STOP    = $FFE1             ; check the STOP key
=$ffe4					GETIN   = $FFE4             ; get a character
=$9519					ORG     = $9519
.8000	a0 20		ldy #$20	SUPER   LDY #MSG4-MSGBAS    ; display "..SYS "
.8002	20 85 89	jsr $8985	        JSR SNDMSG
.8005	ad e6 8a	lda $8ae6	        LDA SUPAD           ; store entry point address in tmp0
.8008	85 c1		sta $c1		        STA TMP0
.800a	ad e7 8a	lda $8ae7	        LDA SUPAD+1
.800d	85 c2		sta $c2		        STA TMP0+1
.800f	20 0f 88	jsr $880f	        JSR CVTDEC          ; convert address to decimal
.8012	a9 00		lda #$00	        LDA #0
.8014	a2 06		ldx #$06	        LDX #6
.8016	a0 03		ldy #$03	        LDY #3
.8018	20 49 88	jsr $8849	        JSR NMPRNT          ; print entry point address
.801b	20 de 86	jsr $86de	        JSR CRLF
.801e	ad e4 8a	lda $8ae4	        LDA LINKAD          ; set BRK vector
.8021	8d 16 03	sta $0316	        STA BKVEC
.8024	ad e5 8a	lda $8ae5	        LDA LINKAD+1
.8027	8d 17 03	sta $0317	        STA BKVEC+1
.802a	a9 80		lda #$80	        LDA #$80            ; disable kernel control messages
.802c	ea		nop		        NOP
.802d	ea		nop		        NOP
.802e	ea		nop		        NOP
.802f	00		brk #		        BRK
.8030	a2 05		ldx #$05	BREAK   LDX #$05            ; pull registers off the stack
.8032	b5 fe		lda $fe,x	BSTACK  LDA $FE,X
.8034	9d 28 02	sta $0228,x	        STA PCH,X
.8037	ca		dex		        DEX
.8038	10 f8		bpl $8032	        BPL BSTACK
.803a	d8		cld		        CLD
.803b	ba		tsx		        TSX
.803c	8e 2e 02	stx $022e	        STX SP
.803f	58		cli		        CLI
.8040	a0 00		ldy #$00	DSPLYR  LDY #MSG2-MSGBAS    ; display headers
.8042	20 72 89	jsr $8972	        JSR SNDCLR
.8045	a9 3b		lda #$3b	        LDA #$3B            ; prefix registers with "; " to allow editing
.8047	20 a0 1e	jsr $1ea0	        JSR CHROUT
.804a	a9 20		lda #$20	        LDA #$20
.804c	20 a0 1e	jsr $1ea0	        JSR CHROUT
.804f	ad 28 02	lda $0228	        LDA PCH             ; print 2-byte program counter
.8052	20 f7 86	jsr $86f7	        JSR WRTWO
.8055	a0 01		ldy #$01	        LDY #1              ; start 1 byte after PC high byte
.8057	b9 28 02	lda $0228,y	DISJ    LDA PCH,Y           ; loop through rest of the registers
.805a	20 d3 86	jsr $86d3	        JSR WRBYTE          ; print 1-byte register value
.805d	c8		iny		        INY
.805e	c0 07		cpy #$07	        CPY #7              ; there are a total of 5 registers to print
.8060	90 f5		bcc $8057	        BCC DISJ
.8062	20 de 86	jsr $86de	STRT    JSR CRLF            ; new line
.8065	a2 00		ldx #$00	        LDX #0              ; point at start of input buffer
.8067	8e 31 02	stx $0231	        STX CHRPNT
.806a	20 5a 1e	jsr $1e5a	SMOVE   JSR INPUT           ; CHRIN kernal call to input a character
.806d	9d 00 02	sta $0200,x	        STA INBUFF,X        ; store in input buffer
.8070	e8		inx		        INX
.8071	e0 28		cpx #$28	        CPX #ENDIN-INBUFF   ; error if buffer is full
.8073	b0 1c		bcs $8091	        BCS ERROR
.8075	c9 0d		cmp #$0d	        CMP #$0D            ; keep reading until CR
.8077	d0 f1		bne $806a	        BNE SMOVE
.8079	a9 00		lda #$00	        LDA #0              ; null-terminate input buffer
.807b	9d ff 01	sta $01ff,x	        STA INBUFF-1,X      ; (replacing the CR)
.807e	20 1f 87	jsr $871f	ST1     JSR GETCHR          ; get a character from the buffer
.8081	f0 df		beq $8062	        BEQ STRT            ; start over if buffer is empty
.8083	c9 20		cmp #$20	        CMP #$20            ; skip leading spaces
.8085	f0 f7		beq $807e	        BEQ ST1
.8087	a2 16		ldx #$16	S0      LDX #KEYTOP-KEYW    ; loop through valid command characters
.8089	dd a8 8a	cmp $8aa8,x	S1      CMP KEYW,X          ; see if input character matches
.808c	f0 0b		beq $8099	        BEQ S2              ; command matched, dispatch it
.808e	ca		dex		        DEX                 ; no match, check next command
.808f	10 f8		bpl $8089	        BPL S1              ; keep trying until we've checked them all
.8091	a0 1e		ldy #$1e	ERROR   LDY #MSG3-MSGBAS    ; display "?" to indicate error and go to new line
.8093	20 85 89	jsr $8985	        JSR SNDMSG
.8096	4c 62 80	jmp $8062	        JMP STRT            ; back to main loop
.8099	e0 13		cpx #$13	S2      CPX #$13            ; last 3 commands in table are load/save/validate
.809b	b0 12		bcs $80af	        BCS LSV             ;   which are handled by the same subroutine
.809d	e0 0f		cpx #$0f	        CPX #$0F            ; next 4 commands are base conversions
.809f	b0 14		bcs $80b5	        BCS CNVLNK          ;   which are handled by the same subroutine
.80a1	8a		txa		        TXA                 ; remaining commands dispatch through vector table
.80a2	0a		asl a		        ASL A               ; multiply index of command by 2
.80a3	aa		tax		        TAX                 ;   since table contains 2-byte addresses
.80a4	bd bf 8a	lda $8abf,x	        LDA KADDR+1,X       ; push address from vector table onto stack
.80a7	48		pha		        PHA                 ;   so that the RTS from GETPAR will jump there
.80a8	bd be 8a	lda $8abe,x	        LDA KADDR,X
.80ab	48		pha		        PHA
.80ac	4c 00 86	jmp $8600	        JMP GETPAR          ; get the first parameter for the command
.80af	8d 32 02	sta $0232	LSV     STA SAVY            ; handle load/save/validate
.80b2	4c 82 82	jmp $8282	        JMP LD
.80b5	4c c4 87	jmp $87c4	CNVLNK  JMP CONVRT          ; handle base conversion
.80b8	4c 00 1c	jmp $1c00	EXIT    JMP $1c00           ; jump to warm-start vector to reinitialize BASIC
.80bb	b0 08		bcs $80c5	DSPLYM  BCS DSPM11          ; start from previous end addr if no address given
.80bd	20 39 87	jsr $8739	        JSR COPY12          ; save start address in TMP2
.80c0	20 00 86	jsr $8600	        JSR GETPAR          ; get end address in TMP0
.80c3	90 06		bcc $80cb	        BCC DSMNEW          ; did user specify one?
.80c5	a9 0b		lda #$0b	DSPM11  LDA #$0B            ; if not, show 12 lines by default
.80c7	85 c1		sta $c1		        STA TMP0
.80c9	d0 0e		bne $80d9	        BNE DSPBYT          ; always true, but BNE uses 1 byte less than JMP
.80cb	20 42 87	jsr $8742	DSMNEW  JSR SUB12           ; end addr given, calc bytes between start and end
.80ce	90 1e		bcc $80ee	        BCC MERROR          ; error if start is after end
.80d0	a2 03		ldx #$03	        LDX #3              ; divide by 8 (shift right 3 times)
.80d2	46 c2		lsr $c2		DSPM01  LSR TMP0+1
.80d4	66 c1		ror $c1		        ROR TMP0
.80d6	ca		dex		        DEX
.80d7	d0 f9		bne $80d2	        BNE DSPM01
.80d9	ea		nop		DSPBYT  NOP
.80da	ea		nop		        NOP
.80db	ea		nop		        NOP
.80dc	ea		nop		        NOP
.80dd	ea		nop		        NOP
.80de	20 5e 81	jsr $815e	        JSR DISPMEM         ; display 1 line containing 8 bytes
.80e1	a9 08		lda #$08	        LDA #8              ; increase start address by 8 bytes
.80e3	20 78 87	jsr $8778	        JSR BUMPAD2
.80e6	20 50 87	jsr $8750	        JSR SUBA1           ; decrement line counter
.80e9	b0 ee		bcs $80d9	        BCS DSPBYT          ; show another line until it's < 0
.80eb	4c 62 80	jmp $8062	DSPMX   JMP STRT            ; back to main loop
.80ee	4c 91 80	jmp $8091	MERROR  JMP ERROR           ; handle error
.80f1	20 90 87	jsr $8790	ALTR    JSR COPY1P          ; store first parameter in PC
.80f4	a0 00		ldy #$00	        LDY #0              ; init counter
.80f6	20 00 86	jsr $8600	ALTR1   JSR GETPAR          ; get value for next register
.80f9	b0 0a		bcs $8105	        BCS ALTRX           ; exit early if no more values given
.80fb	a5 c1		lda $c1		        LDA TMP0            ; store in memory, offset from SR
.80fd	99 2a 02	sta $022a,y	        STA SR,Y            ; these locations will be transferred to the
.8100	c8		iny		        INY                 ;   actual registers before exiting the monitor
.8101	c0 05		cpy #$05	        CPY #$05            ; have we updated all 5 yet?
.8103	90 f1		bcc $80f6	        BCC ALTR1           ; if not, get next
.8105	4c 62 80	jmp $8062	ALTRX   JMP STRT            ; back to main loop
.8108	b0 13		bcs $811d	ALTM    BCS ALTMX           ; exit if no parameter provided
.810a	20 39 87	jsr $8739	        JSR COPY12          ; copy parameter to start address
.810d	a0 00		ldy #$00	        LDY #0
.810f	20 00 86	jsr $8600	ALTM1   JSR GETPAR          ; get value for next byte of memory
.8112	b0 09		bcs $811d	        BCS ALTMX           ; if none given, exit early
.8114	a5 c1		lda $c1		        LDA TMP0            ; poke value into memory at start address + Y
.8116	91 c3		sta ($c3),y	        STA (TMP2),Y
.8118	c8		iny		        INY                 ; next byte
.8119	c0 08		cpy #$08	        CPY #8              ; have we read 8 bytes yet?
.811b	90 f2		bcc $810f	        BCC ALTM1           ; if not, read the next one
.811d	a9 91		lda #$91	ALTMX   LDA #$91            ; move cursor up
.811f	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8122	20 5e 81	jsr $815e	        JSR DISPMEM         ; re-display line to make ascii match hex
.8125	4c 62 80	jmp $8062	        JMP STRT            ; back to main loop
.8128	ae 2e 02	ldx $022e	GOTO    LDX SP              ; load stack pointer from memory
.812b	9a		txs		        TXS                 ; save in SP register
.812c	20 90 87	jsr $8790	GOTO2   JSR COPY1P          ; copy provided address to PC
.812f	78		sei		        SEI                 ; disable interrupts
.8130	ad 28 02	lda $0228	        LDA PCH             ; push PC high byte on stack
.8133	48		pha		        PHA
.8134	ad 29 02	lda $0229	        LDA PCL             ; push PC low byte on stack
.8137	48		pha		        PHA
.8138	ad 2a 02	lda $022a	        LDA SR              ; push status byte on stack
.813b	48		pha		        PHA
.813c	ad 2b 02	lda $022b	        LDA ACC             ; load accumulator from memory
.813f	ae 2c 02	ldx $022c	        LDX XR              ; load X from memory
.8142	ac 2d 02	ldy $022d	        LDY YR              ; load Y from memory
.8145	40		rti		        RTI                 ; return from interrupt (pops PC and SR)
.8146	ae 2e 02	ldx $022e	JSUB    LDX SP              ; load stack pointer from memory
.8149	9a		txs		        TXS                 ; save value in SP register
.814a	20 2c 81	jsr $812c	        JSR GOTO2           ; same as goto command
.814d	8c 2d 02	sty $022d	        STY YR              ; save Y to memory
.8150	8e 2c 02	stx $022c	        STX XR              ; save X to memory
.8153	8d 2b 02	sta $022b	        STA ACC             ; save accumulator to memory
.8156	08		php		        PHP                 ; push processor status on stack
.8157	68		pla		        PLA                 ; pull processor status into A
.8158	8d 2a 02	sta $022a	        STA SR              ; save processor status to memory
.815b	4c 40 80	jmp $8040	        JMP DSPLYR          ; display registers
.815e	20 de 86	jsr $86de	DISPMEM JSR CRLF            ; new line
.8161	a9 3e		lda #$3e	        LDA #">"            ; prefix > so memory can be edited in place
.8163	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8166	20 c9 86	jsr $86c9	        JSR SHOWAD          ; show address of first byte on line
.8169	a0 00		ldy #$00	        LDY #0
.816b	f0 03		beq $8170	        BEQ DMEMGO          ; SHOWAD already printed a space after the address
.816d	20 d6 86	jsr $86d6	DMEMLP  JSR SPACE           ; print space between bytes
.8170	b1 c3		lda ($c3),y	DMEMGO  LDA (TMP2),Y        ; load byte from start address + Y
.8172	20 f7 86	jsr $86f7	        JSR WRTWO           ; output hex digits for byte
.8175	c8		iny		        INY                 ; next byte
.8176	c0 08		cpy #$08	        CPY #8              ; have we output 8 bytes yet?
.8178	90 f3		bcc $816d	        BCC DMEMLP          ; if not, output next byte
.817a	a0 26		ldy #$26	        LDY #MSG5-MSGBAS    ; if so, output : and turn on reverse video
.817c	20 85 89	jsr $8985	        JSR SNDMSG          ;   before displaying ascii representation
.817f	a0 00		ldy #$00	        LDY #0              ; back to first byte in line
.8181	b1 c3		lda ($c3),y	DCHAR   LDA (TMP2),Y        ; load byte at start address + Y
.8183	aa		tax		        TAX                 ; stash in X
.8184	29 bf		and #$bf	        AND #$BF            ; clear 6th bit
.8186	c9 22		cmp #$22	        CMP #$22            ; is it a quote (")?
.8188	f0 08		beq $8192	        BEQ DDOT            ; if so, print . instead
.818a	8a		txa		        TXA                 ; if not, restore character
.818b	29 7f		and #$7f	        AND #$7F            ; clear top bit
.818d	c9 20		cmp #$20	        CMP #$20            ; is it a printable character (>= $20)?
.818f	8a		txa		        TXA                 ; restore character
.8190	b0 02		bcs $8194	        BCS DCHROK          ; if printable, output character
.8192	a9 2e		lda #$2e	DDOT    LDA #$2E            ; if not, output '.' instaed
.8194	20 a0 1e	jsr $1ea0	DCHROK  JSR CHROUT
.8197	c8		iny		        INY                 ; next byte
.8198	c0 08		cpy #$08	        CPY #8              ; have we output 8 bytes yet?
.819a	90 e5		bcc $8181	        BCC DCHAR           ; if not, output next byte
.819c	60		rts		        RTS
.819d	a9 00		lda #$00	COMPAR  LDA #0              ; bit 7 clear signals compare
>819f	2c				        .BYTE $2C           ; absolute BIT opcode consumes next word (LDA #$80)
.81a0	a9 80		lda #$80	TRANS   LDA #$80            ; bit 7 set signals transfer
.81a2	8d 32 02	sta $0232	        STA SAVY            ; save compare/transfer flag in SAVY
.81a5	a9 00		lda #$00	        LDA #0              ; assume we're counting up (bit 7 clear)
.81a7	8d 07 01	sta $0107	        STA UPFLG           ; save direction flag
.81aa	20 9d 87	jsr $879d	        JSR GETDIF          ; get two addresses and calculate difference
.81ad	b0 05		bcs $81b4	        BCS TERROR          ; carry set indicates error
.81af	20 00 86	jsr $8600	        JSR GETPAR          ; get destination address in TMP0
.81b2	90 03		bcc $81b7	        BCC TOKAY           ; carry set indicates error
.81b4	4c 91 80	jmp $8091	TERROR  JMP ERROR           ; handle error
.81b7	2c 32 02	bit $0232	TOKAY   BIT SAVY            ; transfer or compare?
.81ba	10 27		bpl $81e3	        BPL COMPAR1         ; high bit clear indicates compare
.81bc	a5 c3		lda $c3		        LDA TMP2            ; if it's a transfer, we must take steps
.81be	c5 c1		cmp $c1		        CMP TMP0            ;   to avoid overwriting the source bytes before
.81c0	a5 c4		lda $c4		        LDA TMP2+1          ;   they have been transferred
.81c2	e5 c2		sbc $c2		        SBC TMP0+1          ; compare source (TMP2) to destination (TMP0)
.81c4	b0 1d		bcs $81e3	        BCS COMPAR1         ; and count up if source is before than desitnation
.81c6	ad 2f 02	lda $022f	        LDA STORE           ; otherwise, start at end and count down...
.81c9	65 c1		adc $c1		        ADC TMP0            ; add length (STORE) to desintation (TMP0)
.81cb	85 c1		sta $c1		        STA TMP0            ; to calculate end of destination
.81cd	ad 30 02	lda $0230	        LDA STORE+1
.81d0	65 c2		adc $c2		        ADC TMP0+1
.81d2	85 c2		sta $c2		        STA TMP0+1
.81d4	a2 01		ldx #$01	        LDX #1              ; change source pointer from beginning to end
.81d6	bd 0b 01	lda $010b,x	TDOWN   LDA STASH,X         ; TMP2 = source end (STASH)
.81d9	95 c3		sta $c3,x	        STA TMP2,X
.81db	ca		dex		        DEX
.81dc	10 f8		bpl $81d6	        BPL TDOWN
.81de	a9 80		lda #$80	        LDA #$80            ; high bit set in UPFLG means count down
.81e0	8d 07 01	sta $0107	        STA UPFLG
.81e3	20 de 86	jsr $86de	COMPAR1 JSR CRLF            ; new line
.81e6	a0 00		ldy #$00	        LDY #0              ; no offset from pointer
.81e8	ea		nop		TCLOOP  NOP
.81e9	ea		nop		        NOP
.81ea	ea		nop		        NOP
.81eb	ea		nop		        NOP
.81ec	ea		nop		        NOP
.81ed	b1 c3		lda ($c3),y	        LDA (TMP2),Y        ; load byte from source
.81ef	2c 32 02	bit $0232	        BIT SAVY            ; transfer or compare?
.81f2	10 02		bpl $81f6	        BPL COMPAR2         ; skip store if comparing
.81f4	91 c1		sta ($c1),y	        STA (TMP0),Y        ; otherwise, store in destination
.81f6	d1 c1		cmp ($c1),y	COMPAR2 CMP (TMP0),Y        ; compare to destination
.81f8	f0 03		beq $81fd	        BEQ TMVAD           ; don't show address if equal
.81fa	20 c9 86	jsr $86c9	        JSR SHOWAD          ; show address
.81fd	2c 07 01	bit $0107	TMVAD   BIT UPFLG           ; counting up or down?
.8200	30 0b		bmi $820d	        BMI TDECAD          ; high bit set means we're counting down
.8202	e6 c1		inc $c1		        INC TMP0            ; increment destination low byte
.8204	d0 10		bne $8216	        BNE TINCOK
.8206	e6 c2		inc $c2		        INC TMP0+1          ; carry to high byte if necessary
.8208	d0 0c		bne $8216	        BNE TINCOK
.820a	4c 91 80	jmp $8091	        JMP ERROR           ; error if high byte overflowed
.820d	20 50 87	jsr $8750	TDECAD  JSR SUBA1           ; decrement destination (TMP0)
.8210	20 82 87	jsr $8782	        JSR SUB21           ; decrement source (TMP2)
.8213	4c 19 82	jmp $8219	        JMP TMOR
.8216	20 76 87	jsr $8776	TINCOK  JSR ADDA2           ; increment source (TMP2)
.8219	20 64 87	jsr $8764	TMOR    JSR SUB13           ; decrement length
.821c	b0 ca		bcs $81e8	        BCS TCLOOP          ; loop until length is 0
.821e	4c 62 80	jmp $8062	TEXIT   JMP STRT            ; back to main loop
.8221	20 9d 87	jsr $879d	HUNT    JSR GETDIF          ; get start (TMP2) and end (TMP0) of haystack
.8224	b0 59		bcs $827f	        BCS HERROR          ; carry indicates error
.8226	a0 00		ldy #$00	        LDY #0
.8228	20 1f 87	jsr $871f	        JSR GETCHR          ; get a single character
.822b	c9 27		cmp #$27	        CMP #"'"            ; is it a single quote?
.822d	d0 16		bne $8245	        BNE NOSTRH          ; if not, input needle as hex bytes
.822f	20 1f 87	jsr $871f	        JSR GETCHR          ; if so, input needle as string
.8232	c9 00		cmp #$00	        CMP #0
.8234	f0 49		beq $827f	        BEQ HERROR          ; error if needle isn't at least one byte
.8236	99 17 01	sta $0117,y	HPAR    STA STAGE,Y         ; save char in staging area
.8239	c8		iny		        INY
.823a	20 1f 87	jsr $871f	        JSR GETCHR          ; get another char
.823d	f0 18		beq $8257	        BEQ HTGO            ; if it's null start searching
.823f	c0 1e		cpy #$1e	        CPY #ESTAGE-STAGE   ; have we filled up the needle staging area?
.8241	d0 f3		bne $8236	        BNE HPAR            ; if not, get another character
.8243	f0 12		beq $8257	        BEQ HTGO            ; if so, start searching
.8245	20 fd 85	jsr $85fd	NOSTRH  JSR RDPAR           ; read hex bytes if string not indicated
.8248	a5 c1		lda $c1		HLP     LDA TMP0            ; save last read byte in staging area
.824a	99 17 01	sta $0117,y	        STA STAGE,Y
.824d	c8		iny		        INY                 ; get another hex byte
.824e	20 00 86	jsr $8600	        JSR GETPAR
.8251	b0 04		bcs $8257	        BCS HTGO            ; if there is none, start searching
.8253	c0 1e		cpy #$1e	        CPY #ESTAGE-STAGE   ; have we filled up the needle staging area?
.8255	d0 f1		bne $8248	        BNE HLP             ; if not, get another byte
.8257	8c 32 02	sty $0232	HTGO    STY SAVY            ; save length of needle
.825a	20 de 86	jsr $86de	        JSR CRLF            ; new line
.825d	a0 00		ldy #$00	HSCAN   LDY #0
.825f	b1 c3		lda ($c3),y	HLP3    LDA (TMP2),Y        ; get first byte in haystack
.8261	d9 17 01	cmp $0117,y	        CMP STAGE,Y         ; compare it to first byte of needle
.8264	d0 09		bne $826f	        BNE HNOFT           ; if it doesn't match, we haven't found anything
.8266	c8		iny		        INY                 ; if it does, check the next byte
.8267	cc 32 02	cpy $0232	        CPY SAVY            ; have we reached the end of the needle?
.826a	d0 f3		bne $825f	        BNE HLP3            ; if not, keep comparing bytes
.826c	20 c9 86	jsr $86c9	        JSR SHOWAD          ; match found, show address
.826f	ea		nop		HNOFT   NOP
.8270	ea		nop		        NOP
.8271	ea		nop		        NOP
.8272	ea		nop		        NOP
.8273	ea		nop		        NOP
.8274	20 76 87	jsr $8776	        JSR ADDA2           ; increment haystack pointer
.8277	20 64 87	jsr $8764	        JSR SUB13           ; decrement haystack length
.827a	b0 e1		bcs $825d	        BCS HSCAN           ; still more haystack? keep searching
.827c	4c 62 80	jmp $8062	HEXIT   JMP STRT            ; back to main loop
.827f	4c 91 80	jmp $8091	HERROR  JMP ERROR           ; handle error
.8282	a0 01		ldy #$01	LD      LDY #1              ; default to reading from tape, device #1
.8284	84 ba		sty $ba		        STY FA
.8286	84 b9		sty $b9		        STY SADD            ; default to secondary address #1
.8288	88		dey		        DEY
.8289	84 b7		sty $b7		        STY FNLEN           ; start with an empty filename
.828b	84 90		sty $90		        STY SATUS           ; clear status
.828d	a9 01		lda #$01	        LDA #>STAGE         ; set filename pointer to staging buffer
.828f	85 bc		sta $bc		        STA FNADR+1
.8291	a9 17		lda #$17	        LDA #<STAGE
.8293	85 bb		sta $bb		        STA FNADR
.8295	20 1f 87	jsr $871f	L1      JSR GETCHR          ; get a character
.8298	f0 59		beq $82f3	        BEQ LSHORT          ; no filename given, try load or verify from tape
.829a	c9 20		cmp #$20	        CMP #$20            ; skip leading spaces
.829c	f0 f7		beq $8295	        BEQ L1
.829e	c9 22		cmp #$22	        CMP #$22            ; error if filename doesn't start with a quote
.82a0	d0 16		bne $82b8	        BNE LERROR
.82a2	ae 31 02	ldx $0231	        LDX CHRPNT          ; load current char pointer into index reg
.82a5	bd 00 02	lda $0200,x	L3      LDA INBUFF,X        ; load current char from buffer to accumulator
.82a8	f0 49		beq $82f3	        BEQ LSHORT          ; no filename given, try load or verify from tape
.82aa	e8		inx		        INX                 ; next char
.82ab	c9 22		cmp #$22	        CMP #$22            ; is it a quote?
.82ad	f0 0c		beq $82bb	        BEQ L8              ; if so, we've reached the end of the filename
.82af	91 bb		sta ($bb),y	        STA (FNADR),Y       ; if not, save character in filename buffer
.82b1	e6 b7		inc $b7		        INC FNLEN           ; increment filename length
.82b3	c8		iny		        INY
.82b4	c0 1e		cpy #$1e	        CPY #ESTAGE-STAGE   ; check whether buffer is full
.82b6	90 ed		bcc $82a5	        BCC L3              ; if not, get another character
.82b8	4c 91 80	jmp $8091	LERROR  JMP ERROR           ; if so, handle error
.82bb	8e 31 02	stx $0231	L8      STX CHRPNT          ; set character pointer to the current index
.82be	20 1f 87	jsr $871f	        JSR GETCHR          ; eat separator between filename and device #
.82c1	f0 30		beq $82f3	        BEQ LSHORT          ; no separator, try to load or verify from tape
.82c3	20 00 86	jsr $8600	        JSR GETPAR          ; get device number
.82c6	b0 2b		bcs $82f3	        BCS LSHORT          ; no device # given, try load or verify from tape
.82c8	a5 c1		lda $c1		        LDA TMP0            ; set device number for kernal routines
.82ca	85 ba		sta $ba		        STA FA
.82cc	20 00 86	jsr $8600	        JSR GETPAR          ; get start address for load or save in TMP0
.82cf	b0 22		bcs $82f3	        BCS LSHORT          ; no start address, try to load or verify
.82d1	20 39 87	jsr $8739	        JSR COPY12          ; transfer start address to TMP2
.82d4	20 00 86	jsr $8600	        JSR GETPAR          ; get end address for save in TMP0
.82d7	b0 3d		bcs $8316	        BCS LDADDR          ; no end address, try to load to given start addr
.82d9	20 de 86	jsr $86de	        JSR CRLF            ; new line
.82dc	a6 c1		ldx $c1		        LDX TMP0            ; put low byte of end address in X
.82de	a4 c2		ldy $c2		        LDY TMP0+1          ; put high byte of end address in Y
.82e0	ad 32 02	lda $0232	        LDA SAVY            ; confirm that we're doing a save
.82e3	c9 53		cmp #$53	        CMP #"S"
.82e5	d0 d1		bne $82b8	        BNE LERROR          ; if not, error due to too many params
.82e7	a9 00		lda #$00	        LDA #0
.82e9	85 b9		sta $b9		        STA SADD            ; set secondary address to 0
.82eb	a9 c3		lda #$c3	        LDA #TMP2           ; put addr of zero-page pointer to data in A
.82ed	20 d8 ff	jsr $ffd8	        JSR SAVE            ; call kernal save routine
.82f0	4c 62 80	jmp $8062	LSVXIT  JMP STRT            ; back to mainloop
.82f3	ad 32 02	lda $0232	LSHORT  LDA SAVY            ; check which command we received
.82f6	c9 56		cmp #$56	        CMP #"V"
.82f8	f0 06		beq $8300	        BEQ LOADIT          ; we're doing a verify so don't set A to 0
.82fa	c9 4c		cmp #$4c	        CMP #"L"
.82fc	d0 ba		bne $82b8	        BNE LERROR          ; error due to not enough params for save
.82fe	a9 00		lda #$00	        LDA #0              ; 0 in A signals load, anything else is verify
.8300	20 d5 ff	jsr $ffd5	LOADIT  JSR LOAD            ; call kernal load routine
.8303	a5 90		lda $90		        LDA SATUS           ; get i/o status
.8305	29 10		and #$10	        AND #$10            ; check bit 5 for checksum error
.8307	f0 e7		beq $82f0	        BEQ LSVXIT          ; if no error go back to mainloop
.8309	ad 32 02	lda $0232	        LDA SAVY            ; ?? not sure what these two lines are for...
.830c	f0 aa		beq $82b8	        BEQ LERROR          ; ?? SAVY will never be 0, so why check?
.830e	a0 28		ldy #$28	        LDY #MSG6-MSGBAS    ; display "ERROR" if checksum didn't match
.8310	20 85 89	jsr $8985	        JSR SNDMSG
.8313	4c 62 80	jmp $8062	        JMP STRT            ; back to mainloop
.8316	a6 c3		ldx $c3		LDADDR  LDX TMP2            ; load address low byte in X
.8318	a4 c4		ldy $c4		        LDY TMP2+1          ; load address high byte in Y
.831a	a9 00		lda #$00	        LDA #0              ; 0 in A signals load
.831c	85 b9		sta $b9		        STA SADD            ; secondary addr 0 means load to addr in X and Y
.831e	f0 d3		beq $82f3	        BEQ LSHORT          ; execute load
.8320	20 9d 87	jsr $879d	FILL    JSR GETDIF          ; start in TMP2, end in STASH, length in STORE
.8323	b0 59		bcs $837e	        BCS AERROR          ; carry set indicates error
.8325	20 00 86	jsr $8600	        JSR GETPAR          ; get value to fill in TMP0
.8328	b0 54		bcs $837e	        BCS AERROR          ; carry set indicates error
.832a	20 1f 87	jsr $871f	        JSR GETCHR          ; any more characters triggers an error
.832d	d0 4f		bne $837e	        BNE AERROR
.832f	a0 00		ldy #$00	        LDY #0              ; no offset
.8331	a5 c1		lda $c1		FILLP   LDA TMP0            ; load value to fill in accumulator
.8333	91 c3		sta ($c3),y	        STA (TMP2),Y        ; store fill value in current address
.8335	ea		nop		        NOP
.8336	ea		nop		        NOP
.8337	ea		nop		        NOP
.8338	ea		nop		        NOP
.8339	ea		nop		        NOP
.833a	20 76 87	jsr $8776	        JSR ADDA2           ; increment address
.833d	20 64 87	jsr $8764	        JSR SUB13           ; decrement length
.8340	b0 ef		bcs $8331	        BCS FILLP           ; keep going until length reaches 0
.8342	4c 62 80	jmp $8062	FSTART  JMP STRT            ; back to main loop
.8345	b0 37		bcs $837e	ASSEM   BCS AERROR          ; error if no address given
.8347	20 39 87	jsr $8739	        JSR COPY12          ; copy address to TMP2
.834a	a2 00		ldx #$00	AGET1   LDX #0
.834c	8e 0e 01	stx $010e	        STX U0AA0+1         ; clear byte that mnemonic gets shifted into
.834f	8e 08 01	stx $0108	        STX DIGCNT          ; clear digit count
.8352	20 1f 87	jsr $871f	AGET2   JSR GETCHR          ; get a char
.8355	d0 04		bne $835b	        BNE ALMOR           ; proceed if the character isn't null
.8357	e0 00		cpx #$00	        CPX #0              ; it's null, have read a mnemonic yet?
.8359	f0 e7		beq $8342	        BEQ FSTART          ; if not, silently go back to main loop
.835b	c9 20		cmp #$20	ALMOR   CMP #$20            ; skip leading spaces
.835d	f0 eb		beq $834a	        BEQ AGET1
.835f	9d 02 01	sta $0102,x	        STA MNEMW,X         ; put character in mnemonic buffer
.8362	e8		inx		        INX
.8363	e0 03		cpx #$03	        CPX #3              ; have we read 3 characters yet?
.8365	d0 eb		bne $8352	        BNE AGET2           ; if not, get next character
.8367	ca		dex		ASQEEZ  DEX                 ; move to previous char
.8368	30 17		bmi $8381	        BMI AOPRND          ; if we're done with mnemonic, look for operand
.836a	bd 02 01	lda $0102,x	        LDA MNEMW,X         ; get current character
.836d	38		sec		        SEC                 ; pack 3-letter mnemonic into 2 bytes (15 bits)
.836e	e9 3f		sbc #$3f	        SBC #$3F            ; subtract $3F from ascii code so A-Z = 2 to 27
.8370	a0 05		ldy #$05	        LDY #$05            ; letters now fit in 5 bits; shift them out
.8372	4a		lsr a		ASHIFT  LSR A               ;   into the first two bytes of the inst buffer
.8373	6e 0e 01	ror $010e	        ROR U0AA0+1         ; catch the low bit from accumulator in right byte
.8376	6e 0d 01	ror $010d	        ROR U0AA0           ; catch the low bit from right byte in left byte
.8379	88		dey		        DEY                 ; count down bits
.837a	d0 f6		bne $8372	        BNE ASHIFT          ; keep looping until we reach zero
.837c	f0 e9		beq $8367	        BEQ ASQEEZ          ; unconditional branch to handle next char
.837e	4c 91 80	jmp $8091	AERROR  JMP ERROR           ; handle error
.8381	a2 02		ldx #$02	AOPRND  LDX #2              ; mnemonic is in first two bytes so start at third
.8383	ad 08 01	lda $0108	ASCAN   LDA DIGCNT          ; did we find address digits last time?
.8386	d0 2d		bne $83b5	        BNE AFORM1          ; if so, look for mode chars
.8388	20 28 86	jsr $8628	        JSR RDVAL           ; otherwise, look for an address
.838b	f0 25		beq $83b2	        BEQ AFORM0          ; we didn't find an address, look for characters
.838d	b0 ef		bcs $837e	        BCS AERROR          ; carry flag indicates error
.838f	a9 24		lda #$24	        LDA #"$"
.8391	9d 0d 01	sta $010d,x	        STA U0AA0,X         ; prefix addresses with $
.8394	e8		inx		        INX                 ; next position in buffer
.8395	a0 04		ldy #$04	        LDY #4              ; non-zero page addresses are 4 hex digits
.8397	ad 0a 01	lda $010a	        LDA NUMBIT          ; check numeric base in which address was given
.839a	c9 08		cmp #$08	        CMP #8              ; for addresses given in octal or binary
.839c	90 05		bcc $83a3	        BCC AADDR           ;   use only the high byte to determine page
.839e	cc 08 01	cpy $0108	        CPY DIGCNT          ; for decimal or hex, force non-zero page addressing
.83a1	f0 06		beq $83a9	        BEQ AFILL0          ;   if address was given with four digits or more
.83a3	a5 c2		lda $c2		AADDR   LDA TMP0+1          ; check whether high byte of address is zero
.83a5	d0 02		bne $83a9	        BNE AFILL0          ; non-zero high byte means we're not in zero page
.83a7	a0 02		ldy #$02	        LDY #2              ; if it's in zero page, addr is 2 hex digits
.83a9	a9 30		lda #$30	AFILL0  LDA #$30            ; use 0 as placeholder for each hex digit in addr
.83ab	9d 0d 01	sta $010d,x	AFIL0L  STA U0AA0,X         ; put placeholder in assembly buffer
.83ae	e8		inx		        INX                 ; move to next byte in buffer
.83af	88		dey		        DEY                 ; decrement number of remaining digits
.83b0	d0 f9		bne $83ab	        BNE AFIL0L          ; loop until all digits have been placed
.83b2	ce 31 02	dec $0231	AFORM0  DEC CHRPNT          ; non-numeric input; back 1 char to see what it was
.83b5	20 1f 87	jsr $871f	AFORM1  JSR GETCHR          ; get next character
.83b8	f0 0e		beq $83c8	        BEQ AESCAN          ; if there is none, we're finished scanning
.83ba	c9 20		cmp #$20	        CMP #$20            ; skip spaces
.83bc	f0 c5		beq $8383	        BEQ ASCAN
.83be	9d 0d 01	sta $010d,x	        STA U0AA0,X         ; store character in assembly buffer
.83c1	e8		inx		        INX                 ; move to next byte in buffer
.83c2	e0 0a		cpx #$0a	        CPX #U0AAE-U0AA0    ; is instruction buffer full?
.83c4	90 bd		bcc $8383	        BCC ASCAN           ; if not, keep scanning
.83c6	b0 b6		bcs $837e	        BCS AERROR          ; error if buffer is full
.83c8	8e 2f 02	stx $022f	AESCAN  STX STORE           ; save number of bytes in assembly buffer
.83cb	a2 00		ldx #$00	        LDX #0              ; start at opcode $00 and check every one until
.83cd	8e 06 01	stx $0106	        STX OPCODE          ;   we find one that matches our criteria
.83d0	a2 00		ldx #$00	ATRYOP  LDX #0
.83d2	8e 33 02	stx $0233	        STX U9F             ; reset index into work buffer
.83d5	ad 06 01	lda $0106	        LDA OPCODE
.83d8	20 8f 85	jsr $858f	        JSR INSTXX          ; look up instruction format for current opcode
.83db	ae 00 01	ldx $0100	        LDX ACMD            ; save addressing command for later
.83de	8e 30 02	stx $0230	        STX STORE+1
.83e1	aa		tax		        TAX                 ; use current opcode as index
.83e2	bd 64 8a	lda $8a64,x	        LDA MNEMR,X         ; check right byte of compressed mnemonic
.83e5	20 b6 84	jsr $84b6	        JSR CHEKOP
.83e8	bd 24 8a	lda $8a24,x	        LDA MNEML,X         ; check left byte of compressed mnemonic
.83eb	20 b6 84	jsr $84b6	        JSR CHEKOP
.83ee	a2 06		ldx #$06	        LDX #6              ; 6 possible characters to check against operand
.83f0	e0 03		cpx #$03	TRYIT   CPX #3              ; are we on character 3?
.83f2	d0 14		bne $8408	        BNE TRYMOD          ; if not, check operand characters
.83f4	ac 01 01	ldy $0101	        LDY LENGTH          ; otherwise, check number of bytes in operand
.83f7	f0 0f		beq $8408	        BEQ TRYMOD          ; if zero, check operand characters
.83f9	ad 00 01	lda $0100	TRYAD   LDA ACMD            ; otherwise, look for an address
.83fc	c9 e8		cmp #$e8	        CMP #$E8            ; special case for relative addressing mode
.83fe	a9 30		lda #$30	        LDA #$30            ; '0' is the digit placeholder we're looking for
.8400	b0 1e		bcs $8420	        BCS TRY4B           ; ACMD >= $E8 indicates relative addressing
.8402	20 b3 84	jsr $84b3	        JSR CHEK2B          ; ACMD < $E8 indicates normal addressing
.8405	88		dey		        DEY                 ; consume byte
.8406	d0 f1		bne $83f9	        BNE TRYAD           ; check for 2 more digits if not zero-page
.8408	0e 00 01	asl $0100	TRYMOD  ASL ACMD            ; shift a bit out of the addressing command
.840b	90 0e		bcc $841b	        BCC UB4DF           ; if it's zero, skip checking current character
.840d	bd 17 8a	lda $8a17,x	        LDA CHAR1-1,X
.8410	20 b6 84	jsr $84b6	        JSR CHEKOP          ; otherwise first character against operand
.8413	bd 1d 8a	lda $8a1d,x	        LDA CHAR2-1,X       ; get second character to check
.8416	f0 03		beq $841b	        BEQ UB4DF           ; if it's zero, skip checking it
.8418	20 b6 84	jsr $84b6	        JSR CHEKOP          ; otherwise check it against hte operand
.841b	ca		dex		UB4DF   DEX                 ; move to next character
.841c	d0 d2		bne $83f0	        BNE TRYIT           ; repeat tests
.841e	f0 06		beq $8426	        BEQ TRYBRAN
.8420	20 b3 84	jsr $84b3	TRY4B   JSR CHEK2B          ; check for 4 digit address placeholder
.8423	20 b3 84	jsr $84b3	        JSR CHEK2B          ;   by checking for 2 digits twice
.8426	ad 2f 02	lda $022f	TRYBRAN LDA STORE           ; get number of bytes in assembly buffer
.8429	cd 33 02	cmp $0233	        CMP U9F             ; more bytes left to check?
.842c	f0 03		beq $8431	        BEQ ABRAN           ; if not, we've found a match; build instruction
.842e	4c c3 84	jmp $84c3	        JMP BUMPOP          ; if so, this opcode doesn't match; try the next
.8431	ac 01 01	ldy $0101	ABRAN   LDY LENGTH          ; get number of bytes in operand
.8434	f0 32		beq $8468	        BEQ A1BYTE          ; if none, just output the opcode
.8436	ad 30 02	lda $0230	        LDA STORE+1         ; otherwise check the address format
.8439	c9 9d		cmp #$9d	        CMP #$9D            ; is it a relative branch?
.843b	d0 23		bne $8460	        BNE OBJPUT          ; if not, skip relative branch calculation
.843d	a5 c1		lda $c1		        LDA TMP0            ; calculate the difference between the current
.843f	e5 c3		sbc $c3		        SBC TMP2            ;   address and the branch target (low byte)
.8441	aa		tax		        TAX                 ; save it in X
.8442	a5 c2		lda $c2		        LDA TMP0+1          ; borrow from the high byte if necessary
.8444	e5 c4		sbc $c4		        SBC TMP2+1
.8446	90 08		bcc $8450	        BCC ABBACK          ; if result is negative, we're branching back
.8448	d0 66		bne $84b0	        BNE SERROR          ; high bytes must be equal when branching forward
.844a	e0 82		cpx #$82	        CPX #$82            ; difference between low bytes must be < 130
.844c	b0 62		bcs $84b0	        BCS SERROR          ; error if the address is too far away
.844e	90 08		bcc $8458	        BCC ABRANX
.8450	a8		tay		ABBACK  TAY                 ; when branching backward high byte of target must
.8451	c8		iny		        INY                 ;   be 1 less than high byte of current address
.8452	d0 5c		bne $84b0	        BNE SERROR          ; if not, it's too far away
.8454	e0 82		cpx #$82	        CPX #$82            ; difference between low bytes must be < 130
.8456	90 58		bcc $84b0	        BCC SERROR          ; if not, it's too far away
.8458	ca		dex		ABRANX  DEX                 ; adjust branch target relative to the
.8459	ca		dex		        DEX                 ;   instruction following this one
.845a	8a		txa		        TXA
.845b	ac 01 01	ldy $0101	        LDY LENGTH          ; load length of operand
.845e	d0 03		bne $8463	        BNE OBJP2           ; don't use the absolute address
.8460	b9 c0 00	lda $00c0,y	OBJPUT  LDA TMP0-1,Y        ; get the operand
.8463	91 c3		sta ($c3),y	OBJP2   STA (TMP2),Y        ; store it after the opcode
.8465	88		dey		        DEY
.8466	d0 f8		bne $8460	        BNE OBJPUT          ; copy the other byte of operand if there is one
.8468	ad 06 01	lda $0106	A1BYTE  LDA OPCODE          ; put opcode into instruction
.846b	91 c3		sta ($c3),y	        STA (TMP2),Y
.846d	20 de 86	jsr $86de	        JSR CRLF            ; carriage return
.8470	a9 91		lda #$91	        LDA #$91            ; back up one line
.8472	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8475	a0 2e		ldy #$2e	        LDY #MSG7-MSGBAS    ; "A " prefix
.8477	20 72 89	jsr $8972	        JSR SNDCLR          ; clear line
.847a	20 11 85	jsr $8511	        JSR DISLIN          ; disassemble the instruction we just assembled
.847d	ee 01 01	inc $0101	        INC LENGTH          ; instruction length = operand length + 1 byte
.8480	ad 01 01	lda $0101	        LDA LENGTH          ;   for the opcode
.8483	20 78 87	jsr $8778	        JSR BUMPAD2         ; increment address by length of instruction
.8486	a9 41		lda #$41	        LDA #"A"            ; stuff keyboard buffer with next assemble command:
.8488	8d 77 02	sta $0277	        STA KEYD            ;   "A XXXX " where XXXX is the next address
.848b	a9 20		lda #$20	        LDA #" "            ;   after the previously assembled instruction
.848d	8d 78 02	sta $0278	        STA KEYD+1
.8490	8d 7d 02	sta $027d	        STA KEYD+6
.8493	a5 c4		lda $c4		        LDA TMP2+1          ; convert high byte of next address to hex
.8495	20 07 87	jsr $8707	        JSR ASCTWO
.8498	8d 79 02	sta $0279	        STA KEYD+2          ; put it in the keyboard buffer
.849b	8e 7a 02	stx $027a	        STX KEYD+3
.849e	a5 c3		lda $c3		        LDA TMP2            ; convert low byte of next address to hex
.84a0	20 07 87	jsr $8707	        JSR ASCTWO
.84a3	8d 7b 02	sta $027b	        STA KEYD+4          ; put it in the keyboard buffer
.84a6	8e 7c 02	stx $027c	        STX KEYD+5
.84a9	a9 07		lda #$07	        LDA #7              ; set number of chars in keyboard buffer
.84ab	85 c6		sta $c6		        STA NDX
.84ad	4c 62 80	jmp $8062	        JMP STRT            ; back to main loop
.84b0	4c 91 80	jmp $8091	SERROR  JMP ERROR           ; handle error
.84b3	20 b6 84	jsr $84b6	CHEK2B  JSR CHEKOP          ; check two bytes against value in accumulator
.84b6	8e 05 01	stx $0105	CHEKOP  STX SAVX            ; stash X
.84b9	ae 33 02	ldx $0233	        LDX U9F             ; get current index into work buffer
.84bc	dd 0d 01	cmp $010d,x	        CMP U0AA0,X         ; check whether this opcode matches the buffer
.84bf	f0 0a		beq $84cb	        BEQ OPOK            ;   matching so far, check the next criteria
.84c1	68		pla		        PLA                 ; didn't match, so throw away return address
.84c2	68		pla		        PLA                 ;   on the stack because we're starting over
.84c3	ee 06 01	inc $0106	BUMPOP  INC OPCODE          ; check the next opcode
.84c6	f0 e8		beq $84b0	        BEQ SERROR          ; error if we tried every opcode and none fit
.84c8	4c d0 83	jmp $83d0	        JMP ATRYOP          ; start over with new opcode
.84cb	ee 33 02	inc $0233	OPOK    INC U9F             ; opcode matches so far; check the next criteria
.84ce	ae 05 01	ldx $0105	        LDX SAVX            ; restore X
.84d1	60		rts		        RTS
.84d2	b0 08		bcs $84dc	DISASS  BCS DIS0AD          ; if no address was given, start from last address
.84d4	20 39 87	jsr $8739	        JSR COPY12          ; copy start address to TMP2
.84d7	20 00 86	jsr $8600	        JSR GETPAR          ; get end address in TMP0
.84da	90 06		bcc $84e2	        BCC DIS2AD          ; if one was given, skip default
.84dc	a9 14		lda #$14	DIS0AD  LDA #$14            ; disassemble 14 bytes by default
.84de	85 c1		sta $c1		        STA TMP0            ; store length in TMP0
.84e0	d0 05		bne $84e7	        BNE DISGO           ; skip length calculation
.84e2	20 42 87	jsr $8742	DIS2AD  JSR SUB12           ; calculate number of bytes between start and end
.84e5	90 1f		bcc $8506	        BCC DERROR          ; error if end address is before start address
.84e7	20 6c 89	jsr $896c	DISGO   JSR CLINE           ; clear the current line
.84ea	ea		nop		        NOP
.84eb	ea		nop		        NOP
.84ec	ea		nop		        NOP
.84ed	ea		nop		        NOP
.84ee	ea		nop		        NOP
.84ef	20 09 85	jsr $8509	        JSR DSOUT1          ; output disassembly prefix ". "
.84f2	ee 01 01	inc $0101	        INC LENGTH
.84f5	ad 01 01	lda $0101	        LDA LENGTH          ; add length of last instruction to start address
.84f8	20 78 87	jsr $8778	        JSR BUMPAD2
.84fb	ad 01 01	lda $0101	        LDA LENGTH          ; subtract length of last inst from end address
.84fe	20 52 87	jsr $8752	        JSR SUBA2
.8501	b0 e4		bcs $84e7	        BCS DISGO
.8503	4c 62 80	jmp $8062	DISEXIT JMP STRT            ; back to mainloop
.8506	4c 91 80	jmp $8091	DERROR  JMP ERROR
.8509	a9 2e		lda #$2e	DSOUT1  LDA #"."            ; output ". " prefix to allow edit and reassemble
.850b	20 a0 1e	jsr $1ea0	        JSR CHROUT
.850e	20 d6 86	jsr $86d6	        JSR SPACE
.8511	20 c9 86	jsr $86c9	DISLIN  JSR SHOWAD          ; show the address of the instruction
.8514	20 d6 86	jsr $86d6	        JSR SPACE           ; insert a space
.8517	a0 00		ldy #$00	        LDY #0              ; no offset
.8519	b1 c3		lda ($c3),y	        LDA (TMP2),Y        ; load operand of current instruction
.851b	20 8f 85	jsr $858f	        JSR INSTXX          ; get mnemonic and addressing mode for opcode
.851e	48		pha		        PHA                 ; save index into mnemonic table
.851f	ae 01 01	ldx $0101	        LDX LENGTH          ; get length of operand
.8522	e8		inx		        INX                 ; add 1 byte for opcode
.8523	ca		dex		DSBYT   DEX                 ; decrement index
.8524	10 0e		bpl $8534	        BPL DSHEX           ; show hex for byte being disassembled
.8526	8c 32 02	sty $0232	        STY SAVY            ; save index
.8529	a0 30		ldy #$30	        LDY #MSG8-MSGBAS    ; skip 3 spaces
.852b	20 85 89	jsr $8985	        JSR SNDMSG
.852e	ac 32 02	ldy $0232	        LDY SAVY            ; restore index
.8531	4c 39 85	jmp $8539	        JMP NXBYT
.8534	b1 c3		lda ($c3),y	DSHEX   LDA (TMP2),Y        ; show hex for byte
.8536	20 d3 86	jsr $86d3	        JSR WRBYTE
.8539	c8		iny		NXBYT   INY                 ; next byte
.853a	c0 03		cpy #$03	        CPY #3              ; have we output 3 bytes yet?
.853c	90 e5		bcc $8523	        BCC DSBYT           ; if not, loop
.853e	68		pla		        PLA                 ; restore index into mnemonic table
.853f	a2 03		ldx #$03	        LDX #3              ; 3 letters in mnemonic
.8541	20 d7 85	jsr $85d7	        JSR PROPXX          ; print mnemonic
.8544	a2 06		ldx #$06	        LDX #6              ; 6 possible address mode character combos
.8546	e0 03		cpx #$03	PRADR1  CPX #3              ; have we checked the third combo yet?
.8548	d0 16		bne $8560	        BNE PRADR3          ; if so, output the leading characters
.854a	ac 01 01	ldy $0101	        LDY LENGTH          ; get the length of the operand
.854d	f0 11		beq $8560	        BEQ PRADR3          ; if it's zero, there's no operand to print
.854f	ad 00 01	lda $0100	PRADR2  LDA ACMD            ; otherwise, get the addressing mode
.8552	c9 e8		cmp #$e8	        CMP #$E8            ; check for relative addressing
.8554	08		php		        PHP                 ; save result of check
.8555	b1 c3		lda ($c3),y	        LDA (TMP2),Y        ; get the operand
.8557	28		plp		        PLP                 ; restore result of check
.8558	b0 1d		bcs $8577	        BCS RELAD           ; handle a relative address
.855a	20 f7 86	jsr $86f7	        JSR WRTWO           ; output digits from address
.855d	88		dey		        DEY
.855e	d0 ef		bne $854f	        BNE PRADR2          ; repeat for next byte of operand, if there is one
.8560	0e 00 01	asl $0100	PRADR3  ASL ACMD            ; check whether addr mode uses the current char
.8563	90 0e		bcc $8573	        BCC PRADR4          ; if not, skip it
.8565	bd 17 8a	lda $8a17,x	        LDA CHAR1-1,X       ; look up the first char in the table
.8568	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; print first char
.856b	bd 1d 8a	lda $8a1d,x	        LDA CHAR2-1,X       ; look up the second char in the table
.856e	f0 03		beq $8573	        BEQ PRADR4          ; if there's no second character, skip it
.8570	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; print second char
.8573	ca		dex		PRADR4  DEX                 ; next potential address mode character
.8574	d0 d0		bne $8546	        BNE PRADR1          ; loop if we haven't checked them all yet
.8576	60		rts		        RTS                 ; back to caller
.8577	20 83 85	jsr $8583	RELAD   JSR UB64D           ; calculate absolute address from relative
.857a	18		clc		        CLC
.857b	69 01		adc #$01	        ADC #1              ; adjust address relative to next instruction
.857d	d0 01		bne $8580	        BNE RELEND          ; don't increment high byte unless we overflowed
.857f	e8		inx		        INX                 ; increment high byte
.8580	4c cd 86	jmp $86cd	RELEND  JMP WRADDR          ; print address
.8583	a6 c4		ldx $c4		UB64D   LDX TMP2+1          ; get high byte of current address
.8585	a8		tay		        TAY                 ; is relative address positive or negative?
.8586	10 01		bpl $8589	        BPL RELC2           ; if positive, leave high byte alone
.8588	ca		dex		        DEX                 ; if negative, decrement high byte
.8589	65 c3		adc $c3		RELC2   ADC TMP2            ; add relative address to low byte
.858b	90 01		bcc $858e	        BCC RELC3           ; if there's no carry, we're done
.858d	e8		inx		        INX                 ; if there's a carry, increment the high byte
.858e	60		rts		RELC3   RTS
.858f	a8		tay		INSTXX  TAY                 ; stash opcode in accumulator in Y for later
.8590	4a		lsr a		        LSR A               ; is opcode even or odd?
.8591	90 0b		bcc $859e	        BCC IEVEN
.8593	4a		lsr a		        LSR A
.8594	b0 17		bcs $85ad	        BCS ERR             ; invalid opcodes XXXXXX11
.8596	c9 22		cmp #$22	        CMP #$22
.8598	f0 13		beq $85ad	        BEQ ERR             ; invalid opcode 10001001
.859a	29 07		and #$07	        AND #$07            ; mask bits to 10000XXX
.859c	09 80		ora #$80	        ORA #$80
.859e	4a		lsr a		IEVEN   LSR A               ; LSB determines whether to use left/right nybble
.859f	aa		tax		        TAX                 ; get format index using remaining high bytes
.85a0	bd c6 89	lda $89c6,x	        LDA MODE,X
.85a3	b0 04		bcs $85a9	        BCS RTMODE          ; look at left or right nybble based on carry bit
.85a5	4a		lsr a		        LSR A               ; if carry = 0, use left nybble
.85a6	4a		lsr a		        LSR A
.85a7	4a		lsr a		        LSR A
.85a8	4a		lsr a		        LSR A
.85a9	29 0f		and #$0f	RTMODE  AND #$0F            ; if carry = 1, use right nybble
.85ab	d0 04		bne $85b1	        BNE GETFMT
.85ad	a0 80		ldy #$80	ERR     LDY #$80            ; substitute 10000000 for invalid opcodes
.85af	a9 00		lda #$00	        LDA #0
.85b1	aa		tax		GETFMT  TAX
.85b2	bd 0a 8a	lda $8a0a,x	        LDA MODE2,X         ; lookup operand format using selected nybble
.85b5	8d 00 01	sta $0100	        STA ACMD            ; save for later use
.85b8	29 03		and #$03	        AND #$03            ; lower 2 bits indicate number of bytes in operand
.85ba	8d 01 01	sta $0101	        STA LENGTH
.85bd	98		tya		        TYA                 ; restore original opcode
.85be	29 8f		and #$8f	        AND #$8F            ; mask bits to X000XXXX
.85c0	aa		tax		        TAX                 ; save it
.85c1	98		tya		        TYA                 ; restore original opcode
.85c2	a0 03		ldy #$03	        LDY #3
.85c4	e0 8a		cpx #$8a	        CPX #$8A            ; check if opcode = 1XXX1010
.85c6	f0 0b		beq $85d3	        BEQ GTFM4
.85c8	4a		lsr a		GTFM2   LSR A               ; transform opcode into index for mnemonic table
.85c9	90 08		bcc $85d3	        BCC GTFM4
.85cb	4a		lsr a		        LSR A               ; opcodes transformed as follows:
.85cc	4a		lsr a		GTFM3   LSR A               ; 1XXX1010->00101XXX
.85cd	09 20		ora #$20	        ORA #$20            ; XXXYYY01->00111XXX
.85cf	88		dey		        DEY                 ; XXXYYY10->00111XXX
.85d0	d0 fa		bne $85cc	        BNE GTFM3           ; XXXYY100->00110XXX
.85d2	c8		iny		        INY                 ; XXXXX000->000XXXXX
.85d3	88		dey		GTFM4   DEY
.85d4	d0 f2		bne $85c8	        BNE GTFM2
.85d6	60		rts		        RTS
.85d7	a8		tay		PROPXX  TAY                 ; use index in accumulator to look up mnemonic
.85d8	b9 24 8a	lda $8a24,y	        LDA MNEML,Y         ;   and place a temporary copy in STORE
.85db	8d 2f 02	sta $022f	        STA STORE
.85de	b9 64 8a	lda $8a64,y	        LDA MNEMR,Y
.85e1	8d 30 02	sta $0230	        STA STORE+1
.85e4	a9 00		lda #$00	PRMN1   LDA #0              ; clear accumulator
.85e6	a0 05		ldy #$05	        LDY #$05            ; shift 5 times
.85e8	0e 30 02	asl $0230	PRMN2   ASL STORE+1         ; shift right byte
.85eb	2e 2f 02	rol $022f	        ROL STORE           ; rotate bits from right byte into left byte
.85ee	2a		rol a		        ROL A               ; rotate bits from left byte into accumulator
.85ef	88		dey		        DEY                 ; next bit
.85f0	d0 f6		bne $85e8	        BNE PRMN2           ; loop until all bits shifted
.85f2	69 3f		adc #$3f	        ADC #$3F            ; calculate ascii code for letter by adding to '?'
.85f4	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output letter
.85f7	ca		dex		        DEX                 ; next letter
.85f8	d0 ea		bne $85e4	        BNE PRMN1           ; loop until all 3 letters are output
.85fa	4c d6 86	jmp $86d6	        JMP SPACE           ; output space
.85fd	ce 31 02	dec $0231	RDPAR   DEC CHRPNT          ; back up one char
.8600	20 28 86	jsr $8628	GETPAR  JSR RDVAL           ; read the value
.8603	b0 17		bcs $861c	        BCS GTERR           ; carry set indicates error
.8605	20 1c 87	jsr $871c	        JSR GOTCHR          ; check previous character
.8608	d0 0a		bne $8614	        BNE CKTERM          ; if it's not null, check if it's a valid separator
.860a	ce 31 02	dec $0231	        DEC CHRPNT          ; back up one char
.860d	ad 08 01	lda $0108	        LDA DIGCNT          ; get number of digits read
.8610	d0 11		bne $8623	        BNE GETGOT          ; found some digits
.8612	f0 0d		beq $8621	        BEQ GTNIL           ; didn't find any digits
.8614	c9 20		cmp #$20	CKTERM  CMP #$20            ; space or comma are valid separators
.8616	f0 0b		beq $8623	        BEQ GETGOT          ; anything else is an error
.8618	c9 2c		cmp #$2c	        CMP #","
.861a	f0 07		beq $8623	        BEQ GETGOT
.861c	68		pla		GTERR   PLA                 ; encountered error
.861d	68		pla		        PLA                 ; get rid of command vector pushed on stack
.861e	4c 91 80	jmp $8091	        JMP ERROR           ; handle error
.8621	38		sec		GTNIL   SEC                 ; set carry to indicate no parameter found
>8622	24				        .BYTE $24           ; BIT ZP opcode consumes next byte (CLC)
.8623	18		clc		GETGOT  CLC                 ; clear carry to indicate paremeter returned
.8624	ad 08 01	lda $0108	        LDA DIGCNT          ; return number of digits in A
.8627	60		rts		        RTS                 ; return to address pushed from vector table
.8628	a9 00		lda #$00	RDVAL   LDA #0              ; clear temp
.862a	85 c1		sta $c1		        STA TMP0
.862c	85 c2		sta $c2		        STA TMP0+1
.862e	8d 08 01	sta $0108	        STA DIGCNT          ; clear digit counter
.8631	8a		txa		        TXA                 ; save X and Y
.8632	48		pha		        PHA
.8633	98		tya		        TYA
.8634	48		pha		        PHA
.8635	20 1f 87	jsr $871f	RDVMOR  JSR GETCHR          ; get next character from input buffer
.8638	f0 1e		beq $8658	        BEQ RDNILK          ; null at end of buffer
.863a	c9 20		cmp #$20	        CMP #$20            ; skip spaces
.863c	f0 f7		beq $8635	        BEQ RDVMOR
.863e	a2 03		ldx #$03	        LDX #3              ; check numeric base [$+&%]
.8640	dd b7 8a	cmp $8ab7,x	GNMODE  CMP HIKEY,X
.8643	f0 07		beq $864c	        BEQ GOTMOD          ; got a match, set up base
.8645	ca		dex		        DEX
.8646	10 f8		bpl $8640	        BPL GNMODE          ; check next base
.8648	e8		inx		        INX                 ; default to hex
.8649	ce 31 02	dec $0231	        DEC CHRPNT          ; back up one character
.864c	bc dc 8a	ldy $8adc,x	GOTMOD  LDY MODTAB,X        ; get base value
.864f	bd e0 8a	lda $8ae0,x	        LDA LENTAB,X        ; get bits per digit
.8652	8d 0a 01	sta $010a	        STA NUMBIT          ; store bits per digit
.8655	20 1f 87	jsr $871f	NUDIG   JSR GETCHR          ; get next char in A
.8658	f0 63		beq $86bd	RDNILK  BEQ RDNIL           ; end of number if no more characters
.865a	38		sec		        SEC
.865b	e9 30		sbc #$30	        SBC #$30            ; subtract ascii value of 0 to get numeric value
.865d	90 5e		bcc $86bd	        BCC RDNIL           ; end of number if character was less than 0
.865f	c9 0a		cmp #$0a	        CMP #$0A
.8661	90 06		bcc $8669	        BCC DIGMOR          ; not a hex digit if less than A
.8663	e9 07		sbc #$07	        SBC #$07            ; 7 chars between ascii 9 and A, so subtract 7
.8665	c9 10		cmp #$10	        CMP #$10            ; end of number if char is greater than F
.8667	b0 54		bcs $86bd	        BCS RDNIL
.8669	8d 09 01	sta $0109	DIGMOR  STA INDIG           ; store the digit
.866c	cc 09 01	cpy $0109	        CPY INDIG           ; compare base with the digit
.866f	90 4a		bcc $86bb	        BCC RDERR           ; error if the digit >= the base
.8671	f0 48		beq $86bb	        BEQ RDERR
.8673	ee 08 01	inc $0108	        INC DIGCNT          ; increment the number of digits
.8676	c0 0a		cpy #$0a	        CPY #10
.8678	d0 0a		bne $8684	        BNE NODECM          ; skip the next part if not using base 10
.867a	a2 01		ldx #$01	        LDX #1
.867c	b5 c1		lda $c1,x	DECLP1  LDA TMP0,X          ; stash the previous 16-bit value for later use
.867e	9d 0b 01	sta $010b,x	        STA STASH,X
.8681	ca		dex		        DEX
.8682	10 f8		bpl $867c	        BPL DECLP1
.8684	ae 0a 01	ldx $010a	NODECM  LDX NUMBIT          ; number of bits to shift
.8687	06 c1		asl $c1		TIMES2  ASL TMP0            ; shift 16-bit value by specified number of bits
.8689	26 c2		rol $c2		        ROL TMP0+1
.868b	b0 2e		bcs $86bb	        BCS RDERR           ; error if we overflowed 16 bits
.868d	ca		dex		        DEX
.868e	d0 f7		bne $8687	        BNE TIMES2          ; shift remaining bits
.8690	c0 0a		cpy #$0a	        CPY #10
.8692	d0 18		bne $86ac	        BNE NODEC2          ; skip the next part if not using base 10
.8694	0e 0b 01	asl $010b	        ASL STASH           ; shift the previous 16-bit value one bit left
.8697	2e 0c 01	rol $010c	        ROL STASH+1
.869a	b0 1f		bcs $86bb	        BCS RDERR           ; error if we overflowed 16 bits
.869c	ad 0b 01	lda $010b	        LDA STASH           ; add shifted previous value to current value
.869f	65 c1		adc $c1		        ADC TMP0
.86a1	85 c1		sta $c1		        STA TMP0
.86a3	ad 0c 01	lda $010c	        LDA STASH+1
.86a6	65 c2		adc $c2		        ADC TMP0+1
.86a8	85 c2		sta $c2		        STA TMP0+1
.86aa	b0 0f		bcs $86bb	        BCS RDERR           ; error if we overflowed 16 bits
.86ac	18		clc		NODEC2  CLC
.86ad	ad 09 01	lda $0109	        LDA INDIG           ; load current digit
.86b0	65 c1		adc $c1		        ADC TMP0            ; add current digit to low byte
.86b2	85 c1		sta $c1		        STA TMP0            ; and store result back in low byte
.86b4	8a		txa		        TXA                 ; A=0
.86b5	65 c2		adc $c2		        ADC TMP0+1          ; add carry to high byte
.86b7	85 c2		sta $c2		        STA TMP0+1          ; and store result back in high byte
.86b9	90 9a		bcc $8655	        BCC NUDIG           ; get next digit if we didn't overflow
.86bb	38		sec		RDERR   SEC                 ; set carry to indicate error
>86bc	24				        .BYTE $24           ; BIT ZP opcode consumes next byte (CLC)
.86bd	18		clc		RDNIL   CLC                 ; clear carry to indicate success
.86be	8c 0a 01	sty $010a	        STY NUMBIT          ; save base of number
.86c1	68		pla		        PLA                 ; restore X and Y
.86c2	a8		tay		        TAY
.86c3	68		pla		        PLA
.86c4	aa		tax		        TAX
.86c5	ad 08 01	lda $0108	        LDA DIGCNT          ; return number of digits in A
.86c8	60		rts		        RTS
.86c9	a5 c3		lda $c3		SHOWAD  LDA TMP2
.86cb	a6 c4		ldx $c4		        LDX TMP2+1
.86cd	48		pha		WRADDR  PHA                 ; save low byte
.86ce	8a		txa		        TXA                 ; put high byte in A
.86cf	20 f7 86	jsr $86f7	        JSR WRTWO           ; output high byte
.86d2	68		pla		        PLA                 ; restore low byte
.86d3	20 f7 86	jsr $86f7	WRBYTE  JSR WRTWO           ; output byte in A
.86d6	a9 20		lda #$20	SPACE   LDA #$20            ; output space
.86d8	d0 0f		bne $86e9	        BNE FLIP
.86da	c9 0d		cmp #$0d	CHOUT   CMP #$0D            ; output char with special handling of CR
.86dc	d0 0b		bne $86e9	        BNE FLIP
.86de	a9 0d		lda #$0d	CRLF    LDA #$0D            ; load CR in A
.86e0	24 13		bit $13		        BIT $13             ; check default channel
.86e2	10 05		bpl $86e9	        BPL FLIP            ; if high bit is clear output CR only
.86e4	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; otherwise output CR+LF
.86e7	a9 0a		lda #$0a	        LDA #$0A            ; output LF
.86e9	4c a0 1e	jmp $1ea0	FLIP    JMP CHROUT
.86ec	20 de 86	jsr $86de	FRESH   JSR CRLF            ; output CR
.86ef	a9 20		lda #$20	        LDA #$20            ; load space in A
.86f1	20 a0 1e	jsr $1ea0	        JSR CHROUT
.86f4	4c 75 89	jmp $8975	        JMP SNCLR
.86f7	8e 05 01	stx $0105	WRTWO   STX SAVX            ; save X
.86fa	20 07 87	jsr $8707	        JSR ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
.86fd	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output upper nybble
.8700	8a		txa		        TXA                 ; transfer lower to A
.8701	ae 05 01	ldx $0105	        LDX SAVX            ; restore X
.8704	4c a0 1e	jmp $1ea0	        JMP CHROUT          ; output lower nybble
.8707	48		pha		ASCTWO  PHA                 ; save byte
.8708	20 11 87	jsr $8711	        JSR ASCII           ; do low nybble
.870b	aa		tax		        TAX                 ; save in X
.870c	68		pla		        PLA                 ; restore byte
.870d	4a		lsr a		        LSR A               ; shift upper nybble down
.870e	4a		lsr a		        LSR A
.870f	4a		lsr a		        LSR A
.8710	4a		lsr a		        LSR A
.8711	29 0f		and #$0f	ASCII   AND #$0F            ; clear upper nibble
.8713	c9 0a		cmp #$0a	        CMP #$0A            ; if less than A, skip next step
.8715	90 02		bcc $8719	        BCC ASC1
.8717	69 06		adc #$06	        ADC #6              ; skip ascii chars between 9 and A
.8719	69 30		adc #$30	ASC1    ADC #$30            ; add ascii char 0 to value
.871b	60		rts		        RTS
.871c	ce 31 02	dec $0231	GOTCHR  DEC CHRPNT
.871f	8e 05 01	stx $0105	GETCHR  STX SAVX
.8722	ae 31 02	ldx $0231	        LDX CHRPNT          ; get pointer to next char
.8725	bd 00 02	lda $0200,x	        LDA INBUFF,X        ; load next char in A
.8728	f0 06		beq $8730	        BEQ NOCHAR          ; null, :, or ? signal end of buffer
.872a	c9 3a		cmp #$3a	        CMP #":"
.872c	f0 02		beq $8730	        BEQ NOCHAR
.872e	c9 3f		cmp #$3f	        CMP #"?"
.8730	08		php		NOCHAR  PHP
.8731	ee 31 02	inc $0231	        INC CHRPNT          ; next char
.8734	ae 05 01	ldx $0105	        LDX SAVX
.8737	28		plp		        PLP                 ; Z flag will signal last character
.8738	60		rts		        RTS
.8739	a5 c1		lda $c1		COPY12  LDA TMP0            ; low byte
.873b	85 c3		sta $c3		        STA TMP2
.873d	a5 c2		lda $c2		        LDA TMP0+1          ; high byte
.873f	85 c4		sta $c4		        STA TMP2+1
.8741	60		rts		        RTS
.8742	38		sec		SUB12   SEC
.8743	a5 c1		lda $c1		        LDA TMP0            ; subtract low byte
.8745	e5 c3		sbc $c3		        SBC TMP2
.8747	85 c1		sta $c1		        STA TMP0
.8749	a5 c2		lda $c2		        LDA TMP0+1
.874b	e5 c4		sbc $c4		        SBC TMP2+1          ; subtract high byte
.874d	85 c2		sta $c2		        STA TMP0+1
.874f	60		rts		        RTS
.8750	a9 01		lda #$01	SUBA1   LDA #1              ; shortcut to decrement by 1
.8752	8d 05 01	sta $0105	SUBA2   STA SAVX            ; subtrahend in accumulator
.8755	38		sec		        SEC
.8756	a5 c1		lda $c1		        LDA TMP0            ; minuend in low byte
.8758	ed 05 01	sbc $0105	        SBC SAVX
.875b	85 c1		sta $c1		        STA TMP0
.875d	a5 c2		lda $c2		        LDA TMP0+1          ; borrow from high byte
.875f	e9 00		sbc #$00	        SBC #0
.8761	85 c2		sta $c2		        STA TMP0+1
.8763	60		rts		        RTS
.8764	38		sec		SUB13   SEC
.8765	ad 2f 02	lda $022f	        LDA STORE
.8768	e9 01		sbc #$01	        SBC #1              ; decrement low byte
.876a	8d 2f 02	sta $022f	        STA STORE
.876d	ad 30 02	lda $0230	        LDA STORE+1
.8770	e9 00		sbc #$00	        SBC #0              ; borrow from high byte
.8772	8d 30 02	sta $0230	        STA STORE+1
.8775	60		rts		        RTS
.8776	a9 01		lda #$01	ADDA2   LDA #1              ; shortcut to increment by 1
.8778	18		clc		BUMPAD2 CLC
.8779	65 c3		adc $c3		        ADC TMP2            ; add value in accumulator to low byte
.877b	85 c3		sta $c3		        STA TMP2
.877d	90 02		bcc $8781	        BCC BUMPEX
.877f	e6 c4		inc $c4		        INC TMP2+1          ; carry to high byte
.8781	60		rts		BUMPEX  RTS
.8782	38		sec		SUB21   SEC
.8783	a5 c3		lda $c3		        LDA TMP2            ; decrement low byte
.8785	e9 01		sbc #$01	        SBC #1
.8787	85 c3		sta $c3		        STA TMP2
.8789	a5 c4		lda $c4		        LDA TMP2+1          ; borrow from high byte
.878b	e9 00		sbc #$00	        SBC #0
.878d	85 c4		sta $c4		        STA TMP2+1
.878f	60		rts		        RTS
.8790	b0 0a		bcs $879c	COPY1P  BCS CPY1PX          ; do nothing if parameter is empty
.8792	a5 c1		lda $c1		        LDA TMP0            ; copy low byte
.8794	a4 c2		ldy $c2		        LDY TMP0+1          ; copy high byte
.8796	8d 29 02	sta $0229	        STA PCL
.8799	8c 28 02	sty $0228	        STY PCH
.879c	60		rts		CPY1PX  RTS
.879d	b0 23		bcs $87c2	GETDIF  BCS GDIFX           ; exit with error if no parameter given
.879f	20 39 87	jsr $8739	        JSR COPY12          ; save start address in TMP2
.87a2	20 00 86	jsr $8600	        JSR GETPAR          ; get end address in TMP0
.87a5	b0 1b		bcs $87c2	        BCS GDIFX           ; exit with error if no parameter given
.87a7	a5 c1		lda $c1		        LDA TMP0            ; save end address in STASH
.87a9	8d 0b 01	sta $010b	        STA STASH
.87ac	a5 c2		lda $c2		        LDA TMP0+1
.87ae	8d 0c 01	sta $010c	        STA STASH+1
.87b1	20 42 87	jsr $8742	        JSR SUB12           ; subtract start address from end address
.87b4	a5 c1		lda $c1		        LDA TMP0
.87b6	8d 2f 02	sta $022f	        STA STORE           ; save difference in STORE
.87b9	a5 c2		lda $c2		        LDA TMP0+1
.87bb	8d 30 02	sta $0230	        STA STORE+1
.87be	90 02		bcc $87c2	        BCC GDIFX           ; error if start address is after end address
.87c0	18		clc		        CLC                 ; clear carry to indicate success
>87c1	24				        .BYTE $24           ; BIT ZP opcode consumes next byte (SEC)
.87c2	38		sec		GDIFX   SEC                 ; set carry to indicate error
.87c3	60		rts		        RTS
.87c4	20 fd 85	jsr $85fd	CONVRT  JSR RDPAR           ; read a parameter
.87c7	20 ec 86	jsr $86ec	        JSR FRESH           ; next line and clear
.87ca	a9 24		lda #$24	        LDA #"$"            ; output $ sigil for hex
.87cc	20 a0 1e	jsr $1ea0	        JSR CHROUT
.87cf	a5 c1		lda $c1		        LDA TMP0            ; load the 16-bit value entered
.87d1	a6 c2		ldx $c2		        LDX TMP0+1
.87d3	20 cd 86	jsr $86cd	        JSR WRADDR          ; print it in 4 hex digits
.87d6	20 ec 86	jsr $86ec	        JSR FRESH
.87d9	a9 2b		lda #$2b	        LDA #"+"            ; output + sigil for decimal
.87db	20 a0 1e	jsr $1ea0	        JSR CHROUT
.87de	20 0f 88	jsr $880f	        JSR CVTDEC          ; convert to BCD using hardware mode
.87e1	a9 00		lda #$00	        LDA #0              ; clear digit counter
.87e3	a2 06		ldx #$06	        LDX #6              ; max digits + 1
.87e5	a0 03		ldy #$03	        LDY #3              ; bits per digit - 1
.87e7	20 49 88	jsr $8849	        JSR NMPRNT          ; print result without leading zeros
.87ea	20 ec 86	jsr $86ec	        JSR FRESH           ; next line and clear
.87ed	a9 26		lda #$26	        LDA #"&"            ; print & sigil for octal
.87ef	20 a0 1e	jsr $1ea0	        JSR CHROUT
.87f2	a9 00		lda #$00	        LDA #0              ; clear digit counter
.87f4	a2 08		ldx #$08	        LDX #8              ; max digits + 1
.87f6	a0 02		ldy #$02	        LDY #2              ; bits per digit - 1
.87f8	20 38 88	jsr $8838	        JSR PRINUM          ; output number
.87fb	20 ec 86	jsr $86ec	        JSR FRESH           ; next line and clear
.87fe	a9 25		lda #$25	        LDA #"%"            ; print % sigil for binary
.8800	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8803	a9 00		lda #$00	        LDA #0              ; clear digit counter
.8805	a2 18		ldx #$18	        LDX #$18            ; max digits + 1
.8807	a0 00		ldy #$00	        LDY #0              ; bits per digit - 1
.8809	20 38 88	jsr $8838	        JSR PRINUM          ; output number
.880c	4c 62 80	jmp $8062	        JMP STRT            ; back to mainloop
.880f	20 39 87	jsr $8739	CVTDEC  JSR COPY12          ; copy value from TMP0 to TMP2
.8812	a9 00		lda #$00	        LDA #0
.8814	a2 02		ldx #$02	        LDX #2              ; clear 3 bytes in work buffer
.8816	9d 0d 01	sta $010d,x	DECML1  STA U0AA0,X
.8819	ca		dex		        DEX
.881a	10 fa		bpl $8816	        BPL DECML1
.881c	a0 10		ldy #$10	        LDY #16             ; 16 bits in input
.881e	08		php		        PHP                 ; save status register
.881f	78		sei		        SEI                 ; make sure no interrupts occur with BCD enabled
.8820	f8		sed		        SED
.8821	06 c3		asl $c3		DECML2  ASL TMP2            ; rotate bytes out of input low byte
.8823	26 c4		rol $c4		        ROL TMP2+1          ; .. into high byte and carry bit
.8825	a2 02		ldx #$02	        LDX #2              ; process 3 bytes
.8827	bd 0d 01	lda $010d,x	DECDBL  LDA U0AA0,X         ; load current value of byte
.882a	7d 0d 01	adc $010d,x	        ADC U0AA0,X         ; add it to itself plus the carry bit
.882d	9d 0d 01	sta $010d,x	        STA U0AA0,X         ; store it back in the same location
.8830	ca		dex		        DEX                 ; decrement byte counter
.8831	10 f4		bpl $8827	        BPL DECDBL          ; loop until all bytes processed
.8833	88		dey		        DEY                 ; decrement bit counter
.8834	d0 eb		bne $8821	        BNE DECML2          ; loop until all bits processed
.8836	28		plp		        PLP                 ; restore processor status
.8837	60		rts		        RTS
.8838	48		pha		PRINUM  PHA                 ; save accumulator
.8839	a5 c1		lda $c1		        LDA TMP0            ; copy input low byte to work buffer
.883b	8d 0f 01	sta $010f	        STA U0AA0+2
.883e	a5 c2		lda $c2		        LDA TMP0+1          ; copy input high byte to work buffer
.8840	8d 0e 01	sta $010e	        STA U0AA0+1
.8843	a9 00		lda #$00	        LDA #0              ; clear overflow byte in work buffer
.8845	8d 0d 01	sta $010d	        STA U0AA0
.8848	68		pla		        PLA                 ; restore accumulator
.8849	8d 08 01	sta $0108	NMPRNT  STA DIGCNT          ; number of digits in accumulator
.884c	8c 0a 01	sty $010a	        STY NUMBIT          ; bits per digit passed in Y register
.884f	ac 0a 01	ldy $010a	DIGOUT  LDY NUMBIT          ; get bits to process
.8852	a9 00		lda #$00	        LDA #0              ; clear accumulator
.8854	0e 0f 01	asl $010f	ROLBIT  ASL U0AA0+2         ; shift bits out of low byte
.8857	2e 0e 01	rol $010e	        ROL U0AA0+1         ; ... into high byte
.885a	2e 0d 01	rol $010d	        ROL U0AA0           ; ... into overflow byte
.885d	2a		rol a		        ROL A               ; ... into accumulator
.885e	88		dey		        DEY                 ; decrement bit counter
.885f	10 f3		bpl $8854	        BPL ROLBIT          ; loop until all bits processed
.8861	a8		tay		        TAY                 ; check whether accumulator is 0
.8862	d0 09		bne $886d	        BNE NZERO           ; if not, print it
.8864	e0 01		cpx #$01	        CPX #1              ; have we output the max number of digits?
.8866	f0 05		beq $886d	        BEQ NZERO           ; if not, print it
.8868	ac 08 01	ldy $0108	        LDY DIGCNT          ; how many digits have we output?
.886b	f0 08		beq $8875	        BEQ ZERSUP          ; skip output if digit is 0
.886d	ee 08 01	inc $0108	NZERO   INC DIGCNT          ; increment digit counter
.8870	09 30		ora #$30	        ORA #$30            ; add numeric value to ascii '0' to get ascii char
.8872	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output character
.8875	ca		dex		ZERSUP  DEX                 ; decrement number of leading zeros
.8876	d0 d7		bne $884f	        BNE DIGOUT          ; next digit
.8878	60		rts		        RTS
.8879	d0 03		bne $887e	DSTAT   BNE CHGDEV          ; if device address was given, use it
.887b	a2 08		ldx #$08	        LDX #8              ; otherwise, default to 8
>887d	2c				        .BYTE $2C           ; absolute BIT opcode consumes next word (LDX TMP0)
.887e	a6 c1		ldx $c1		CHGDEV  LDX TMP0            ; load device address from parameter
.8880	e0 04		cpx #$04	        CPX #4              ; make sure device address is in range 4-31
.8882	90 58		bcc $88dc	        BCC IOERR
.8884	e0 20		cpx #$20	        CPX #32
.8886	b0 54		bcs $88dc	        BCS IOERR
.8888	86 c1		stx $c1		        STX TMP0
.888a	a9 00		lda #$00	        LDA #0              ; clear status
.888c	85 90		sta $90		        STA SATUS
.888e	85 b7		sta $b7		        STA FNLEN           ; empty filename
.8890	20 1f 87	jsr $871f	        JSR GETCHR          ; get next character
.8893	f0 24		beq $88b9	        BEQ INSTAT1         ; null, display status
.8895	ce 31 02	dec $0231	        DEC CHRPNT          ; back up 1 char
.8898	c9 24		cmp #$24	        CMP #"$"            ; $, display directory
.889a	f0 43		beq $88df	        BEQ DIRECT
.889c	a5 c1		lda $c1		        LDA TMP0            ; command specified device to listen
.889e	20 b1 ff	jsr $ffb1	        JSR LISTEN
.88a1	a9 6f		lda #$6f	        LDA #$6F            ; secondary address 15 (only low nybble used)
.88a3	20 93 ff	jsr $ff93	        JSR SECOND
.88a6	ae 31 02	ldx $0231	DCOMD   LDX CHRPNT          ; get next character from buffer
.88a9	ee 31 02	inc $0231	        INC CHRPNT
.88ac	bd 00 02	lda $0200,x	        LDA INBUFF,X
.88af	f0 05		beq $88b6	        BEQ INSTAT          ; break out of loop if it's null
.88b1	20 a8 ff	jsr $ffa8	        JSR CIOUT           ; otherwise output it to the serial bus
.88b4	90 f0		bcc $88a6	        BCC DCOMD           ; unconditional loop: CIOUT clears carry before RTS
.88b6	20 ae ff	jsr $ffae	INSTAT  JSR UNLSN           ; command device to unlisten
.88b9	20 de 86	jsr $86de	INSTAT1 JSR CRLF            ; new line
.88bc	a5 c1		lda $c1		        LDA TMP0            ; load device address
.88be	20 b4 ff	jsr $ffb4	        JSR TALK            ; command device to talk
.88c1	a9 6f		lda #$6f	        LDA #$6F            ; secondary address 15 (only low nybble used)
.88c3	20 96 ff	jsr $ff96	        JSR TKSA
.88c6	20 a5 ff	jsr $ffa5	RDSTAT  JSR ACPTR           ; read byte from serial bus
.88c9	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; print it
.88cc	c9 0d		cmp #$0d	        CMP #$0D            ; if the byte is CR, exit loop
.88ce	f0 06		beq $88d6	        BEQ DEXIT
.88d0	a5 90		lda $90		        LDA SATUS           ; check status
.88d2	29 bf		and #$bf	        AND #$BF            ; ignore EOI bit
.88d4	f0 f0		beq $88c6	        BEQ RDSTAT          ; if no errors, read next byte
.88d6	20 ab ff	jsr $ffab	DEXIT   JSR UNTLK           ; command device to stop talking
.88d9	4c 62 80	jmp $8062	        JMP STRT            ; back to mainloop
.88dc	4c 91 80	jmp $8091	IOERR   JMP ERROR           ; handle error
.88df	a5 c1		lda $c1		DIRECT  LDA TMP0            ; load device address
.88e1	20 b1 ff	jsr $ffb1	        JSR LISTEN          ; command device to listen
.88e4	a9 f0		lda #$f0	        LDA #$F0            ; secondary address 0 (only low nybble used)
.88e6	20 93 ff	jsr $ff93	        JSR SECOND
.88e9	ae 31 02	ldx $0231	        LDX CHRPNT          ; get index of next character
.88ec	bd 00 02	lda $0200,x	DIR2    LDA INBUFF,X        ; get next character from buffer
.88ef	f0 06		beq $88f7	        BEQ DIR3            ; break if it's null
.88f1	20 a8 ff	jsr $ffa8	        JSR CIOUT           ; send character to device
.88f4	e8		inx		        INX                 ; increment characer index
.88f5	d0 f5		bne $88ec	        BNE DIR2            ; loop if it hasn't wrapped to zero
.88f7	20 ae ff	jsr $ffae	DIR3    JSR UNLSN           ; command device to unlisten
.88fa	20 de 86	jsr $86de	        JSR CRLF            ; new line
.88fd	a5 c1		lda $c1		        LDA TMP0            ; load device address
.88ff	48		pha		        PHA                 ; save on stack
.8900	20 b4 ff	jsr $ffb4	        JSR TALK            ; command device to talk
.8903	a9 60		lda #$60	        LDA #$60            ; secondary address 0 (only low nybble used)
.8905	20 96 ff	jsr $ff96	        JSR TKSA
.8908	a0 03		ldy #$03	        LDY #3              ; read 3 16-bit values from device
.890a	8c 2f 02	sty $022f	DIRLIN  STY STORE           ;   ignore the first 2; 3rd is file size
.890d	20 a5 ff	jsr $ffa5	DLINK   JSR ACPTR           ; read low byte from device
.8910	85 c1		sta $c1		        STA TMP0            ; store it
.8912	a5 90		lda $90		        LDA SATUS           ; check status
.8914	d0 44		bne $895a	        BNE DREXIT          ; exit if error or eof occurred
.8916	20 a5 ff	jsr $ffa5	        JSR ACPTR           ; read high byte from device
.8919	85 c2		sta $c2		        STA TMP0+1          ; store it
.891b	a5 90		lda $90		        LDA SATUS           ; check status
.891d	d0 3b		bne $895a	        BNE DREXIT          ; exit if error or eof cocurred
.891f	ce 2f 02	dec $022f	        DEC STORE           ; decrement byte count
.8922	d0 e9		bne $890d	        BNE DLINK           ; loop if bytes remain
.8924	20 0f 88	jsr $880f	        JSR CVTDEC          ; convert last 16-bit value to decimal
.8927	a9 00		lda #$00	        LDA #0              ; clear digit count
.8929	a2 06		ldx #$06	        LDX #6              ; max 6 digits
.892b	a0 03		ldy #$03	        LDY #3              ; 3 bits per digit
.892d	20 49 88	jsr $8849	        JSR NMPRNT          ; output number
.8930	a9 20		lda #$20	        LDA #" "            ; output space
.8932	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8935	20 a5 ff	jsr $ffa5	DNAME   JSR ACPTR           ; get a filename character from the device
.8938	f0 0a		beq $8944	        BEQ DMORE           ; if it's null, break out of loop
.893a	a6 90		ldx $90		        LDX SATUS           ; check for errors or eof
.893c	d0 1c		bne $895a	        BNE DREXIT          ; if found exit early
.893e	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output character
.8941	18		clc		        CLC
.8942	90 f1		bcc $8935	        BCC DNAME           ; unconditional branch to read next char
.8944	20 de 86	jsr $86de	DMORE   JSR CRLF
.8947	20 e1 ff	jsr $ffe1	        JSR STOP            ; check for stop key
.894a	f0 0e		beq $895a	        BEQ DREXIT          ; exit early if pressed
.894c	20 e4 ff	jsr $ffe4	        JSR GETIN           ; pause if a key was pressed
.894f	f0 05		beq $8956	        BEQ NOPAWS
.8951	20 e4 ff	jsr $ffe4	PAWS    JSR GETIN           ; wait until another key is pressed
.8954	f0 fb		beq $8951	        BEQ PAWS
.8956	a0 02		ldy #$02	NOPAWS  LDY #2
.8958	d0 b0		bne $890a	        BNE DIRLIN          ; unconditional branch to read next file
.895a	20 ab ff	jsr $ffab	DREXIT  JSR UNTLK           ; command device to untalk
.895d	68		pla		        PLA                 ; restore accumulator
.895e	20 b1 ff	jsr $ffb1	        JSR LISTEN          ; command device to listen
.8961	a9 e0		lda #$e0	        LDA #$E0            ; secondary address 0 (only low nybble is used)
.8963	20 93 ff	jsr $ff93	        JSR SECOND
.8966	20 ae ff	jsr $ffae	        JSR UNLSN           ; command device to unlisten
.8969	4c 62 80	jmp $8062	        JMP STRT            ; back to mainloop
.896c	20 de 86	jsr $86de	CLINE   JSR CRLF            ; send CR+LF
.896f	4c 75 89	jmp $8975	        JMP SNCLR           ; clear line
.8972	20 85 89	jsr $8985	SNDCLR  JSR SNDMSG
.8975	a0 28		ldy #$28	SNCLR   LDY #$28            ; loop 40 times
.8977	a9 20		lda #$20	SNCLP   LDA #$20            ; output space character
.8979	20 a0 1e	jsr $1ea0	        JSR CHROUT
.897c	a9 14		lda #$14	        LDA #$14            ; output delete character
.897e	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8981	88		dey		        DEY
.8982	d0 f3		bne $8977	        BNE SNCLP
.8984	60		rts		        RTS
.8985	b9 93 89	lda $8993,y	SNDMSG  LDA MSGBAS,Y        ; Y contains offset in msg table
.8988	08		php		        PHP
.8989	29 7f		and #$7f	        AND #$7F            ; strip high bit before output
.898b	20 da 86	jsr $86da	        JSR CHOUT
.898e	c8		iny		        INY
.898f	28		plp		        PLP
.8990	10 f3		bpl $8985	        BPL SNDMSG          ; loop until high bit is set
.8992	60		rts		        RTS
=$8993					MSGBAS  =*
>8993	0d				MSG2    .BYTE $0D               ; header for registers
>8994	20 20 20 50 43 20 20 53		        .TEXT "   PC  SR AC XR YR SP   V1.2"
>899c	52 20 41 43 20 58 52 20 59 52 20 53 50 20 20 20
>89ac	56 31 2e 32
>89b0	8d				        .BYTE $0D+$80
>89b1	1d bf				MSG3    .BYTE $1D,$3F+$80       ; syntax error: move right, display "?"
>89b3	2e 2e 53 59 53			MSG4    .TEXT "..SYS"           ; SYS call to enter monitor
>89b8	a0				        .BYTE $20+$80
>89b9	3a 92				MSG5    .BYTE $3A,$12+$80       ; ":" then RVS ON for memory ASCII dump
>89bb	20 45 52 52 4f			MSG6    .TEXT " ERRO"           ; I/O error: display " ERROR"
>89c0	d2				        .BYTE "R"+$80
>89c1	41 a0				MSG7    .BYTE $41,$20+$80       ; assemble next instruction: "A " + addr
>89c3	20 20				MSG8    .TEXT "  "              ; pad non-existent byte: skip 3 spaces
>89c5	a0				        .BYTE $20+$80
>89c6	40 02 45 03			MODE    .BYTE $40,$02,$45,$03   ; even opcodes
>89ca	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89ce	30 22 45 33			        .BYTE $30,$22,$45,$33
>89d2	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89d6	40 02 45 33			        .BYTE $40,$02,$45,$33
>89da	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89de	40 02 45 b3			        .BYTE $40,$02,$45,$B3
>89e2	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89e6	00 22 44 33			        .BYTE $00,$22,$44,$33
>89ea	d0 8c 44 00			        .BYTE $D0,$8C,$44,$00
>89ee	11 22 44 33			        .BYTE $11,$22,$44,$33
>89f2	d0 8c 44 9a			        .BYTE $D0,$8C,$44,$9A
>89f6	10 22 44 33			        .BYTE $10,$22,$44,$33
>89fa	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89fe	10 22 44 33			        .BYTE $10,$22,$44,$33
>8a02	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>8a06	62 13 78 a9			        .BYTE $62,$13,$78,$A9   ; opcodes ending in 01
>8a0a	00				MODE2   .BYTE $00   ; 000 000    00                  0   error
>8a0b	21				        .BYTE $21   ; 001 000    01      #$00        1   immediate
>8a0c	81				        .BYTE $81   ; 100 000    01      $00         2   zero-page
>8a0d	82				        .BYTE $82   ; 100 000    10      $0000       3   absolute
>8a0e	00				        .BYTE $00   ; 000 000    00                  4   implied
>8a0f	00				        .BYTE $00   ; 000 000    00                  5   accumulator
>8a10	59				        .BYTE $59   ; 010 110    01      ($00,X)     6   indirect,X
>8a11	4d				        .BYTE $4D   ; 010 011    01      ($00),Y     7   indirect,Y
>8a12	91				        .BYTE $91   ; 100 100    01      $00,X       8   zero-page,X
>8a13	92				        .BYTE $92   ; 100 100    10      $0000,X     9   absolute,X
>8a14	86				        .BYTE $86   ; 100 001    10      $0000,Y     A   absolute,Y
>8a15	4a				        .BYTE $4A   ; 010 010    10      ($0000)     B   indirect
>8a16	85				        .BYTE $85   ; 100 001    01      $00,Y       C   zero-page,Y
>8a17	9d				        .BYTE $9D   ; 100 111    01      $0000*      D   relative
>8a18	2c 29 2c			CHAR1   .BYTE $2C,$29,$2C       ; ","  ")"  ","
>8a1b	23 28 24			        .BYTE $23,$28,$24       ; "#"  "("  "$"
>8a1e	59 00 58			CHAR2   .BYTE $59,$00,$58       ; "Y"   0   "X"
>8a21	24 24 00			        .BYTE $24,$24,$00       ; "$"  "$"   0
>8a24	1c 8a 1c 23			MNEML   .BYTE $1C,$8A,$1C,$23   ; BRK PHP BPL CLC
>8a28	5d 8b 1b a1			        .BYTE $5D,$8B,$1B,$A1   ; JSR PLP BMI SEC
>8a2c	9d 8a 1d 23			        .BYTE $9D,$8A,$1D,$23   ; RTI PHA BVC CLI
>8a30	9d 8b 1d a1			        .BYTE $9D,$8B,$1D,$A1   ; RTS PLA BVS SEI
>8a34	00 29 19 ae			        .BYTE $00,$29,$19,$AE   ; ??? DEY BCC TYA
>8a38	69 a8 19 23			        .BYTE $69,$A8,$19,$23   ; LDY TAY BCS CLV
>8a3c	24 53 1b 23			        .BYTE $24,$53,$1B,$23   ; CPY INY BNE CLD
>8a40	24 53 19 a1			        .BYTE $24,$53,$19,$A1   ; CPX INX BEQ SED
>8a44	00 1a 5b 5b			        .BYTE $00,$1A,$5B,$5B   ; ??? BIT JMP JMP
>8a48	a5 69 24 24			        .BYTE $A5,$69,$24,$24   ; STY LDY CPY CPX
>8a4c	ae ae a8 ad			        .BYTE $AE,$AE,$A8,$AD   ; TXA TXS TAX TSX
>8a50	29 00 7c 00			        .BYTE $29,$00,$7C,$00   ; DEX ??? NOP ???
>8a54	15 9c 6d 9c			        .BYTE $15,$9C,$6D,$9C   ; ASL ROL LSR ROR
>8a58	a5 69 29 53			        .BYTE $A5,$69,$29,$53   ; STX LDX DEC INC
>8a5c	84 13 34 11			        .BYTE $84,$13,$34,$11   ; ORA AND EOR ADC
>8a60	a5 69 23 a0			        .BYTE $A5,$69,$23,$A0   ; STA LDA CMP SBC
>8a64	d8 62 5a 48			MNEMR   .BYTE $D8,$62,$5A,$48   ; BRK PHP BPL CLC
>8a68	26 62 94 88			        .BYTE $26,$62,$94,$88   ; JSR PLP BMI SEC
>8a6c	54 44 c8 54			        .BYTE $54,$44,$C8,$54   ; RTI PHA BVC CLI
>8a70	68 44 e8 94			        .BYTE $68,$44,$E8,$94   ; RTS PLA BVS SEI
>8a74	00 b4 08 84			        .BYTE $00,$B4,$08,$84   ; ??? DEY BCC TYA
>8a78	74 b4 28 6e			        .BYTE $74,$B4,$28,$6E   ; LDY TAY BCS CLV
>8a7c	74 f4 cc 4a			        .BYTE $74,$F4,$CC,$4A   ; CPY INY BNE CLD
>8a80	72 f2 a4 8a			        .BYTE $72,$F2,$A4,$8A   ; CPX INX BEQ SED
>8a84	00 aa a2 a2			        .BYTE $00,$AA,$A2,$A2   ; ??? BIT JMP JMP
>8a88	74 74 74 72			        .BYTE $74,$74,$74,$72   ; STY LDY CPY CPX
>8a8c	44 68 b2 32			        .BYTE $44,$68,$B2,$32   ; TXA TXS TAX TSX
>8a90	b2 00 22 00			        .BYTE $B2,$00,$22,$00   ; DEX ??? NOP ???
>8a94	1a 1a 26 26			        .BYTE $1A,$1A,$26,$26   ; ASL ROL LSR ROR
>8a98	72 72 88 c8			        .BYTE $72,$72,$88,$C8   ; STX LDX DEC INC
>8a9c	c4 ca 26 48			        .BYTE $C4,$CA,$26,$48   ; ORA AND EOR ADC
>8aa0	44 44 a2 c8			        .BYTE $44,$44,$A2,$C8   ; STA LDA CMP SBC
>8aa4	0d 20 20 20			        .BYTE $0D,$20,$20,$20
>8aa8	41 43 44 46 47 48 4a 4d		KEYW    .TEXT "ACDFGHJMRTX@.>;"
>8ab0	52 54 58 40 2e 3e 3b
>8ab7	24 2b 26 25 4c 53 56		HIKEY   .TEXT "$+&%LSV"
=$8abe					KEYTOP  =*
>8abe	44 83 9c 81 d1 84 1f 83		KADDR   .WORD ASSEM-1,COMPAR-1,DISASS-1,FILL-1
>8ac6	27 81 20 82 45 81 ba 80		        .WORD GOTO-1,HUNT-1,JSUB-1,DSPLYM-1
>8ace	3f 80 9f 81 b7 80 78 88		        .WORD DSPLYR-1,TRANS-1,EXIT-1,DSTAT-1
>8ad6	44 83 07 81 f0 80		        .WORD ASSEM-1,ALTM-1,ALTR-1
>8adc	10 0a 08 02			MODTAB  .BYTE $10,$0A,$08,02    ; modulo number systems
>8ae0	04 03 03 01			LENTAB  .BYTE $04,$03,$03,$01   ; bits per digit
>8ae4	30 80				LINKAD  .WORD BREAK             ; address of brk handler
>8ae6	00 80				SUPAD   .WORD SUPER             ; address of entry point

;******  End of listing
