
; 64tass Turbo Assembler Macro V1.56.2625 listing file
; 64tass -L 8000 -i -o supermon64-8000.prg "-DORG=\$8000" supermon64.asm
; Thu Jun 23 19:14:37 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$8000					ORG=$8000

;******  Processing input file: supermon64.asm

=$c1					TMP0    = $C1               ; used to return input, often holds end address
=$c3					TMP2    = $C3               ; usually holds start address
=$90					SATUS   = $90               ; kernal i/o status word
=$b7					FNLEN   = $B7               ; length of current filename
=$b9					SADD    = $B9               ; current secondary address (official name SA)
=$ba					FA      = $BA               ; current device number
=$bb					FNADR   = $BB               ; pointer to current filename
=$c6					NDX     = $C6               ; number of characters in keyboard buffer
=$0277					KEYD    = $0277             ; keyboard buffer
=$17fe					BKVEC   = $17FE             ; BRK instruction vector (official name CBINV)
>0100					ACMD    .FILL 1             ; addressing command
>0101					LENGTH  .FILL 1             ; length of operand
>0102					MNEMW   .FILL 3             ; 3 letter mnemonic buffer
>0105					SAVX    .FILL 1             ; 1 byte temp storage, often to save X register
>0106					OPCODE  .FILL 1             ; current opcode for assembler/disassembler
>0107					UPFLG   .FILL 1             ; flag: count up (bit 7 clear) or down (bit 7 set)
>0108					DIGCNT  .FILL 1             ; digit count
>0109					INDIG   .FILL 1             ; numeric value of single digit
>010a					NUMBIT  .FILL 1             ; numeric base of input
>010b					STASH   .FILL 2             ; 2-byte temp storage
>010d					U0AA0   .FILL 10            ; work buffer
=$0117					U0AAE   =*                  ; end of work buffer
>0117					STAGE   .FILL 30            ; staging buffer for filename, search, etc.
=$0135					ESTAGE  =*                  ; end of staging buffer
>0200					INBUFF  .FILL 40            ; 40-character input buffer
=$0228					ENDIN   =*                  ; end of input buffer
>0228					PCH     .FILL 1             ; program counter high byte
>0229					PCL     .FILL 1             ; program counter low byte
>022a					SR      .FILL 1             ; status register
>022b					ACC     .FILL 1             ; accumulator
>022c					XR      .FILL 1             ; X register
>022d					YR      .FILL 1             ; Y register
>022e					SP      .FILL 1             ; stack pointer
>022f					STORE   .FILL 2             ; 2-byte temp storage
>0231					CHRPNT  .FILL 1             ; current position in input buffer
>0232					SAVY    .FILL 1             ; temp storage, often to save Y register
>0233					U9F     .FILL 1             ; index into assembler work buffer
=$ff90					SETMSG  = $FF90             ; set kernel message control flag
=$ff93					SECOND  = $FF93             ; set secondary address after LISTEN
=$ff96					TKSA    = $FF96             ; send secondary address after TALK
=$ffb1					LISTEN  = $FFB1             ; command serial bus device to LISTEN
=$ffb4					TALK    = $FFB4             ; command serial bus device to TALK
=$ffba					SETLFS  = $FFBA             ; set logical file parameters
=$ffbd					SETNAM  = $FFBD             ; set filename
=$ffa5					ACPTR   = $FFA5             ; input byte from serial bus
=$ffa8					CIOUT   = $FFA8             ; output byte to serial bus
=$ffab					UNTLK   = $FFAB             ; command serial bus device to UNTALK
=$ffae					UNLSN   = $FFAE             ; command serial bus device to UNLISTEN
=$ffc6					CHKIN   = $FFC6             ; define input channel
=$ffcc					CLRCHN  = $FFCC             ; restore default devices
=$1e5a					INPUT   = $1E5A             ; input a character (official name CHRIN)
=$1ea0					CHROUT  = $1EA0             ; output a character
=$ffd5					LOAD    = $FFD5             ; load from device
=$ffd8					SAVE    = $FFD8             ; save to device
=$ffe1					STOP    = $FFE1             ; check the STOP key
=$ffe4					GETIN   = $FFE4             ; get a character
=$9519					ORG     = $9519
.8000	a0 20		ldy #$20	SUPER   LDY #MSG4-MSGBAS    ; display "..SYS "
.8002	20 84 89	jsr $8984	        JSR SNDMSG
.8005	ad e5 8a	lda $8ae5	        LDA SUPAD           ; store entry point address in tmp0
.8008	85 c1		sta $c1		        STA TMP0
.800a	ad e6 8a	lda $8ae6	        LDA SUPAD+1
.800d	85 c2		sta $c2		        STA TMP0+1
.800f	20 0e 88	jsr $880e	        JSR CVTDEC          ; convert address to decimal
.8012	a9 00		lda #$00	        LDA #0
.8014	a2 06		ldx #$06	        LDX #6
.8016	a0 03		ldy #$03	        LDY #3
.8018	20 48 88	jsr $8848	        JSR NMPRNT          ; print entry point address
.801b	20 dd 86	jsr $86dd	        JSR CRLF
.801e	ad e3 8a	lda $8ae3	        LDA LINKAD          ; set BRK vector
.8021	8d fe 17	sta $17fe	        STA BKVEC
.8024	ad e4 8a	lda $8ae4	        LDA LINKAD+1
.8027	8d ff 17	sta $17ff	        STA BKVEC+1
.802a	a9 80		lda #$80	        LDA #$80            ; disable kernel control messages
.802c	ea		nop		        NOP
.802d	ea		nop		        NOP
.802e	ea		nop		        NOP
.802f	00		brk #		        BRK
.8030	a2 05		ldx #$05	BREAK   LDX #$05            ; pull registers off the stack
.8032	68		pla		BSTACK  PLA                 ; order: Y,X,A,SR,PCL,PCH
.8033	9d 28 02	sta $0228,x	        STA PCH,X           ; store in memory
.8036	ca		dex		        DEX
.8037	10 f9		bpl $8032	        BPL BSTACK
.8039	d8		cld		        CLD                 ; disable bcd mode
.803a	ba		tsx		        TSX                 ; store stack pointer in memory
.803b	8e 2e 02	stx $022e	        STX SP
.803e	58		cli		        CLI                 ; enable interupts
.803f	a0 00		ldy #$00	DSPLYR  LDY #MSG2-MSGBAS    ; display headers
.8041	20 71 89	jsr $8971	        JSR SNDCLR
.8044	a9 3b		lda #$3b	        LDA #$3B            ; prefix registers with "; " to allow editing
.8046	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8049	a9 20		lda #$20	        LDA #$20
.804b	20 a0 1e	jsr $1ea0	        JSR CHROUT
.804e	ad 28 02	lda $0228	        LDA PCH             ; print 2-byte program counter
.8051	20 f6 86	jsr $86f6	        JSR WRTWO
.8054	a0 01		ldy #$01	        LDY #1              ; start 1 byte after PC high byte
.8056	b9 28 02	lda $0228,y	DISJ    LDA PCH,Y           ; loop through rest of the registers
.8059	20 d2 86	jsr $86d2	        JSR WRBYTE          ; print 1-byte register value
.805c	c8		iny		        INY
.805d	c0 07		cpy #$07	        CPY #7              ; there are a total of 5 registers to print
.805f	90 f5		bcc $8056	        BCC DISJ
.8061	20 dd 86	jsr $86dd	STRT    JSR CRLF            ; new line
.8064	a2 00		ldx #$00	        LDX #0              ; point at start of input buffer
.8066	8e 31 02	stx $0231	        STX CHRPNT
.8069	20 5a 1e	jsr $1e5a	SMOVE   JSR INPUT           ; CHRIN kernal call to input a character
.806c	9d 00 02	sta $0200,x	        STA INBUFF,X        ; store in input buffer
.806f	e8		inx		        INX
.8070	e0 28		cpx #$28	        CPX #ENDIN-INBUFF   ; error if buffer is full
.8072	b0 1c		bcs $8090	        BCS ERROR
.8074	c9 0d		cmp #$0d	        CMP #$0D            ; keep reading until CR
.8076	d0 f1		bne $8069	        BNE SMOVE
.8078	a9 00		lda #$00	        LDA #0              ; null-terminate input buffer
.807a	9d ff 01	sta $01ff,x	        STA INBUFF-1,X      ; (replacing the CR)
.807d	20 1e 87	jsr $871e	ST1     JSR GETCHR          ; get a character from the buffer
.8080	f0 df		beq $8061	        BEQ STRT            ; start over if buffer is empty
.8082	c9 20		cmp #$20	        CMP #$20            ; skip leading spaces
.8084	f0 f7		beq $807d	        BEQ ST1
.8086	a2 16		ldx #$16	S0      LDX #KEYTOP-KEYW    ; loop through valid command characters
.8088	dd a7 8a	cmp $8aa7,x	S1      CMP KEYW,X          ; see if input character matches
.808b	f0 0b		beq $8098	        BEQ S2              ; command matched, dispatch it
.808d	ca		dex		        DEX                 ; no match, check next command
.808e	10 f8		bpl $8088	        BPL S1              ; keep trying until we've checked them all
.8090	a0 1e		ldy #$1e	ERROR   LDY #MSG3-MSGBAS    ; display "?" to indicate error and go to new line
.8092	20 84 89	jsr $8984	        JSR SNDMSG
.8095	4c 61 80	jmp $8061	        JMP STRT            ; back to main loop
.8098	e0 13		cpx #$13	S2      CPX #$13            ; last 3 commands in table are load/save/validate
.809a	b0 12		bcs $80ae	        BCS LSV             ;   which are handled by the same subroutine
.809c	e0 0f		cpx #$0f	        CPX #$0F            ; next 4 commands are base conversions
.809e	b0 14		bcs $80b4	        BCS CNVLNK          ;   which are handled by the same subroutine
.80a0	8a		txa		        TXA                 ; remaining commands dispatch through vector table
.80a1	0a		asl a		        ASL A               ; multiply index of command by 2
.80a2	aa		tax		        TAX                 ;   since table contains 2-byte addresses
.80a3	bd be 8a	lda $8abe,x	        LDA KADDR+1,X       ; push address from vector table onto stack
.80a6	48		pha		        PHA                 ;   so that the RTS from GETPAR will jump there
.80a7	bd bd 8a	lda $8abd,x	        LDA KADDR,X
.80aa	48		pha		        PHA
.80ab	4c ff 85	jmp $85ff	        JMP GETPAR          ; get the first parameter for the command
.80ae	8d 32 02	sta $0232	LSV     STA SAVY            ; handle load/save/validate
.80b1	4c 81 82	jmp $8281	        JMP LD
.80b4	4c c3 87	jmp $87c3	CNVLNK  JMP CONVRT          ; handle base conversion
.80b7	4c 00 1c	jmp $1c00	EXIT    JMP $1c00           ; jump to warm-start vector to reinitialize BASIC
.80ba	b0 08		bcs $80c4	DSPLYM  BCS DSPM11          ; start from previous end addr if no address given
.80bc	20 38 87	jsr $8738	        JSR COPY12          ; save start address in TMP2
.80bf	20 ff 85	jsr $85ff	        JSR GETPAR          ; get end address in TMP0
.80c2	90 06		bcc $80ca	        BCC DSMNEW          ; did user specify one?
.80c4	a9 0b		lda #$0b	DSPM11  LDA #$0B            ; if not, show 12 lines by default
.80c6	85 c1		sta $c1		        STA TMP0
.80c8	d0 0e		bne $80d8	        BNE DSPBYT          ; always true, but BNE uses 1 byte less than JMP
.80ca	20 41 87	jsr $8741	DSMNEW  JSR SUB12           ; end addr given, calc bytes between start and end
.80cd	90 1e		bcc $80ed	        BCC MERROR          ; error if start is after end
.80cf	a2 03		ldx #$03	        LDX #3              ; divide by 8 (shift right 3 times)
.80d1	46 c2		lsr $c2		DSPM01  LSR TMP0+1
.80d3	66 c1		ror $c1		        ROR TMP0
.80d5	ca		dex		        DEX
.80d6	d0 f9		bne $80d1	        BNE DSPM01
.80d8	ea		nop		DSPBYT  NOP
.80d9	ea		nop		        NOP
.80da	ea		nop		        NOP
.80db	ea		nop		        NOP
.80dc	ea		nop		        NOP
.80dd	20 5d 81	jsr $815d	        JSR DISPMEM         ; display 1 line containing 8 bytes
.80e0	a9 08		lda #$08	        LDA #8              ; increase start address by 8 bytes
.80e2	20 77 87	jsr $8777	        JSR BUMPAD2
.80e5	20 4f 87	jsr $874f	        JSR SUBA1           ; decrement line counter
.80e8	b0 ee		bcs $80d8	        BCS DSPBYT          ; show another line until it's < 0
.80ea	4c 61 80	jmp $8061	DSPMX   JMP STRT            ; back to main loop
.80ed	4c 90 80	jmp $8090	MERROR  JMP ERROR           ; handle error
.80f0	20 8f 87	jsr $878f	ALTR    JSR COPY1P          ; store first parameter in PC
.80f3	a0 00		ldy #$00	        LDY #0              ; init counter
.80f5	20 ff 85	jsr $85ff	ALTR1   JSR GETPAR          ; get value for next register
.80f8	b0 0a		bcs $8104	        BCS ALTRX           ; exit early if no more values given
.80fa	a5 c1		lda $c1		        LDA TMP0            ; store in memory, offset from SR
.80fc	99 2a 02	sta $022a,y	        STA SR,Y            ; these locations will be transferred to the
.80ff	c8		iny		        INY                 ;   actual registers before exiting the monitor
.8100	c0 05		cpy #$05	        CPY #$05            ; have we updated all 5 yet?
.8102	90 f1		bcc $80f5	        BCC ALTR1           ; if not, get next
.8104	4c 61 80	jmp $8061	ALTRX   JMP STRT            ; back to main loop
.8107	b0 13		bcs $811c	ALTM    BCS ALTMX           ; exit if no parameter provided
.8109	20 38 87	jsr $8738	        JSR COPY12          ; copy parameter to start address
.810c	a0 00		ldy #$00	        LDY #0
.810e	20 ff 85	jsr $85ff	ALTM1   JSR GETPAR          ; get value for next byte of memory
.8111	b0 09		bcs $811c	        BCS ALTMX           ; if none given, exit early
.8113	a5 c1		lda $c1		        LDA TMP0            ; poke value into memory at start address + Y
.8115	91 c3		sta ($c3),y	        STA (TMP2),Y
.8117	c8		iny		        INY                 ; next byte
.8118	c0 08		cpy #$08	        CPY #8              ; have we read 8 bytes yet?
.811a	90 f2		bcc $810e	        BCC ALTM1           ; if not, read the next one
.811c	a9 91		lda #$91	ALTMX   LDA #$91            ; move cursor up
.811e	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8121	20 5d 81	jsr $815d	        JSR DISPMEM         ; re-display line to make ascii match hex
.8124	4c 61 80	jmp $8061	        JMP STRT            ; back to main loop
.8127	ae 2e 02	ldx $022e	GOTO    LDX SP              ; load stack pointer from memory
.812a	9a		txs		        TXS                 ; save in SP register
.812b	20 8f 87	jsr $878f	GOTO2   JSR COPY1P          ; copy provided address to PC
.812e	78		sei		        SEI                 ; disable interrupts
.812f	ad 28 02	lda $0228	        LDA PCH             ; push PC high byte on stack
.8132	48		pha		        PHA
.8133	ad 29 02	lda $0229	        LDA PCL             ; push PC low byte on stack
.8136	48		pha		        PHA
.8137	ad 2a 02	lda $022a	        LDA SR              ; push status byte on stack
.813a	48		pha		        PHA
.813b	ad 2b 02	lda $022b	        LDA ACC             ; load accumulator from memory
.813e	ae 2c 02	ldx $022c	        LDX XR              ; load X from memory
.8141	ac 2d 02	ldy $022d	        LDY YR              ; load Y from memory
.8144	40		rti		        RTI                 ; return from interrupt (pops PC and SR)
.8145	ae 2e 02	ldx $022e	JSUB    LDX SP              ; load stack pointer from memory
.8148	9a		txs		        TXS                 ; save value in SP register
.8149	20 2b 81	jsr $812b	        JSR GOTO2           ; same as goto command
.814c	8c 2d 02	sty $022d	        STY YR              ; save Y to memory
.814f	8e 2c 02	stx $022c	        STX XR              ; save X to memory
.8152	8d 2b 02	sta $022b	        STA ACC             ; save accumulator to memory
.8155	08		php		        PHP                 ; push processor status on stack
.8156	68		pla		        PLA                 ; pull processor status into A
.8157	8d 2a 02	sta $022a	        STA SR              ; save processor status to memory
.815a	4c 3f 80	jmp $803f	        JMP DSPLYR          ; display registers
.815d	20 dd 86	jsr $86dd	DISPMEM JSR CRLF            ; new line
.8160	a9 3e		lda #$3e	        LDA #">"            ; prefix > so memory can be edited in place
.8162	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8165	20 c8 86	jsr $86c8	        JSR SHOWAD          ; show address of first byte on line
.8168	a0 00		ldy #$00	        LDY #0
.816a	f0 03		beq $816f	        BEQ DMEMGO          ; SHOWAD already printed a space after the address
.816c	20 d5 86	jsr $86d5	DMEMLP  JSR SPACE           ; print space between bytes
.816f	b1 c3		lda ($c3),y	DMEMGO  LDA (TMP2),Y        ; load byte from start address + Y
.8171	20 f6 86	jsr $86f6	        JSR WRTWO           ; output hex digits for byte
.8174	c8		iny		        INY                 ; next byte
.8175	c0 08		cpy #$08	        CPY #8              ; have we output 8 bytes yet?
.8177	90 f3		bcc $816c	        BCC DMEMLP          ; if not, output next byte
.8179	a0 26		ldy #$26	        LDY #MSG5-MSGBAS    ; if so, output : and turn on reverse video
.817b	20 84 89	jsr $8984	        JSR SNDMSG          ;   before displaying ascii representation
.817e	a0 00		ldy #$00	        LDY #0              ; back to first byte in line
.8180	b1 c3		lda ($c3),y	DCHAR   LDA (TMP2),Y        ; load byte at start address + Y
.8182	aa		tax		        TAX                 ; stash in X
.8183	29 bf		and #$bf	        AND #$BF            ; clear 6th bit
.8185	c9 22		cmp #$22	        CMP #$22            ; is it a quote (")?
.8187	f0 08		beq $8191	        BEQ DDOT            ; if so, print . instead
.8189	8a		txa		        TXA                 ; if not, restore character
.818a	29 7f		and #$7f	        AND #$7F            ; clear top bit
.818c	c9 20		cmp #$20	        CMP #$20            ; is it a printable character (>= $20)?
.818e	8a		txa		        TXA                 ; restore character
.818f	b0 02		bcs $8193	        BCS DCHROK          ; if printable, output character
.8191	a9 2e		lda #$2e	DDOT    LDA #$2E            ; if not, output '.' instaed
.8193	20 a0 1e	jsr $1ea0	DCHROK  JSR CHROUT
.8196	c8		iny		        INY                 ; next byte
.8197	c0 08		cpy #$08	        CPY #8              ; have we output 8 bytes yet?
.8199	90 e5		bcc $8180	        BCC DCHAR           ; if not, output next byte
.819b	60		rts		        RTS
.819c	a9 00		lda #$00	COMPAR  LDA #0              ; bit 7 clear signals compare
>819e	2c				        .BYTE $2C           ; absolute BIT opcode consumes next word (LDA #$80)
.819f	a9 80		lda #$80	TRANS   LDA #$80            ; bit 7 set signals transfer
.81a1	8d 32 02	sta $0232	        STA SAVY            ; save compare/transfer flag in SAVY
.81a4	a9 00		lda #$00	        LDA #0              ; assume we're counting up (bit 7 clear)
.81a6	8d 07 01	sta $0107	        STA UPFLG           ; save direction flag
.81a9	20 9c 87	jsr $879c	        JSR GETDIF          ; get two addresses and calculate difference
.81ac	b0 05		bcs $81b3	        BCS TERROR          ; carry set indicates error
.81ae	20 ff 85	jsr $85ff	        JSR GETPAR          ; get destination address in TMP0
.81b1	90 03		bcc $81b6	        BCC TOKAY           ; carry set indicates error
.81b3	4c 90 80	jmp $8090	TERROR  JMP ERROR           ; handle error
.81b6	2c 32 02	bit $0232	TOKAY   BIT SAVY            ; transfer or compare?
.81b9	10 27		bpl $81e2	        BPL COMPAR1         ; high bit clear indicates compare
.81bb	a5 c3		lda $c3		        LDA TMP2            ; if it's a transfer, we must take steps
.81bd	c5 c1		cmp $c1		        CMP TMP0            ;   to avoid overwriting the source bytes before
.81bf	a5 c4		lda $c4		        LDA TMP2+1          ;   they have been transferred
.81c1	e5 c2		sbc $c2		        SBC TMP0+1          ; compare source (TMP2) to destination (TMP0)
.81c3	b0 1d		bcs $81e2	        BCS COMPAR1         ; and count up if source is before than desitnation
.81c5	ad 2f 02	lda $022f	        LDA STORE           ; otherwise, start at end and count down...
.81c8	65 c1		adc $c1		        ADC TMP0            ; add length (STORE) to desintation (TMP0)
.81ca	85 c1		sta $c1		        STA TMP0            ; to calculate end of destination
.81cc	ad 30 02	lda $0230	        LDA STORE+1
.81cf	65 c2		adc $c2		        ADC TMP0+1
.81d1	85 c2		sta $c2		        STA TMP0+1
.81d3	a2 01		ldx #$01	        LDX #1              ; change source pointer from beginning to end
.81d5	bd 0b 01	lda $010b,x	TDOWN   LDA STASH,X         ; TMP2 = source end (STASH)
.81d8	95 c3		sta $c3,x	        STA TMP2,X
.81da	ca		dex		        DEX
.81db	10 f8		bpl $81d5	        BPL TDOWN
.81dd	a9 80		lda #$80	        LDA #$80            ; high bit set in UPFLG means count down
.81df	8d 07 01	sta $0107	        STA UPFLG
.81e2	20 dd 86	jsr $86dd	COMPAR1 JSR CRLF            ; new line
.81e5	a0 00		ldy #$00	        LDY #0              ; no offset from pointer
.81e7	20 e1 ff	jsr $ffe1	TCLOOP  JSR STOP            ; check for stop key
.81ea	f0 31		beq $821d	        BEQ TEXIT           ; exit if pressed
.81ec	b1 c3		lda ($c3),y	        LDA (TMP2),Y        ; load byte from source
.81ee	2c 32 02	bit $0232	        BIT SAVY            ; transfer or compare?
.81f1	10 02		bpl $81f5	        BPL COMPAR2         ; skip store if comparing
.81f3	91 c1		sta ($c1),y	        STA (TMP0),Y        ; otherwise, store in destination
.81f5	d1 c1		cmp ($c1),y	COMPAR2 CMP (TMP0),Y        ; compare to destination
.81f7	f0 03		beq $81fc	        BEQ TMVAD           ; don't show address if equal
.81f9	20 c8 86	jsr $86c8	        JSR SHOWAD          ; show address
.81fc	2c 07 01	bit $0107	TMVAD   BIT UPFLG           ; counting up or down?
.81ff	30 0b		bmi $820c	        BMI TDECAD          ; high bit set means we're counting down
.8201	e6 c1		inc $c1		        INC TMP0            ; increment destination low byte
.8203	d0 10		bne $8215	        BNE TINCOK
.8205	e6 c2		inc $c2		        INC TMP0+1          ; carry to high byte if necessary
.8207	d0 0c		bne $8215	        BNE TINCOK
.8209	4c 90 80	jmp $8090	        JMP ERROR           ; error if high byte overflowed
.820c	20 4f 87	jsr $874f	TDECAD  JSR SUBA1           ; decrement destination (TMP0)
.820f	20 81 87	jsr $8781	        JSR SUB21           ; decrement source (TMP2)
.8212	4c 18 82	jmp $8218	        JMP TMOR
.8215	20 75 87	jsr $8775	TINCOK  JSR ADDA2           ; increment source (TMP2)
.8218	20 63 87	jsr $8763	TMOR    JSR SUB13           ; decrement length
.821b	b0 ca		bcs $81e7	        BCS TCLOOP          ; loop until length is 0
.821d	4c 61 80	jmp $8061	TEXIT   JMP STRT            ; back to main loop
.8220	20 9c 87	jsr $879c	HUNT    JSR GETDIF          ; get start (TMP2) and end (TMP0) of haystack
.8223	b0 59		bcs $827e	        BCS HERROR          ; carry indicates error
.8225	a0 00		ldy #$00	        LDY #0
.8227	20 1e 87	jsr $871e	        JSR GETCHR          ; get a single character
.822a	c9 27		cmp #$27	        CMP #"'"            ; is it a single quote?
.822c	d0 16		bne $8244	        BNE NOSTRH          ; if not, input needle as hex bytes
.822e	20 1e 87	jsr $871e	        JSR GETCHR          ; if so, input needle as string
.8231	c9 00		cmp #$00	        CMP #0
.8233	f0 49		beq $827e	        BEQ HERROR          ; error if needle isn't at least one byte
.8235	99 17 01	sta $0117,y	HPAR    STA STAGE,Y         ; save char in staging area
.8238	c8		iny		        INY
.8239	20 1e 87	jsr $871e	        JSR GETCHR          ; get another char
.823c	f0 18		beq $8256	        BEQ HTGO            ; if it's null start searching
.823e	c0 1e		cpy #$1e	        CPY #ESTAGE-STAGE   ; have we filled up the needle staging area?
.8240	d0 f3		bne $8235	        BNE HPAR            ; if not, get another character
.8242	f0 12		beq $8256	        BEQ HTGO            ; if so, start searching
.8244	20 fc 85	jsr $85fc	NOSTRH  JSR RDPAR           ; read hex bytes if string not indicated
.8247	a5 c1		lda $c1		HLP     LDA TMP0            ; save last read byte in staging area
.8249	99 17 01	sta $0117,y	        STA STAGE,Y
.824c	c8		iny		        INY                 ; get another hex byte
.824d	20 ff 85	jsr $85ff	        JSR GETPAR
.8250	b0 04		bcs $8256	        BCS HTGO            ; if there is none, start searching
.8252	c0 1e		cpy #$1e	        CPY #ESTAGE-STAGE   ; have we filled up the needle staging area?
.8254	d0 f1		bne $8247	        BNE HLP             ; if not, get another byte
.8256	8c 32 02	sty $0232	HTGO    STY SAVY            ; save length of needle
.8259	20 dd 86	jsr $86dd	        JSR CRLF            ; new line
.825c	a0 00		ldy #$00	HSCAN   LDY #0
.825e	b1 c3		lda ($c3),y	HLP3    LDA (TMP2),Y        ; get first byte in haystack
.8260	d9 17 01	cmp $0117,y	        CMP STAGE,Y         ; compare it to first byte of needle
.8263	d0 09		bne $826e	        BNE HNOFT           ; if it doesn't match, we haven't found anything
.8265	c8		iny		        INY                 ; if it does, check the next byte
.8266	cc 32 02	cpy $0232	        CPY SAVY            ; have we reached the end of the needle?
.8269	d0 f3		bne $825e	        BNE HLP3            ; if not, keep comparing bytes
.826b	20 c8 86	jsr $86c8	        JSR SHOWAD          ; match found, show address
.826e	20 e1 ff	jsr $ffe1	HNOFT   JSR STOP            ; no match, check for stop key
.8271	f0 08		beq $827b	        BEQ HEXIT           ; exit prematurely if pressed
.8273	20 75 87	jsr $8775	        JSR ADDA2           ; increment haystack pointer
.8276	20 63 87	jsr $8763	        JSR SUB13           ; decrement haystack length
.8279	b0 e1		bcs $825c	        BCS HSCAN           ; still more haystack? keep searching
.827b	4c 61 80	jmp $8061	HEXIT   JMP STRT            ; back to main loop
.827e	4c 90 80	jmp $8090	HERROR  JMP ERROR           ; handle error
.8281	a0 01		ldy #$01	LD      LDY #1              ; default to reading from tape, device #1
.8283	84 ba		sty $ba		        STY FA
.8285	84 b9		sty $b9		        STY SADD            ; default to secondary address #1
.8287	88		dey		        DEY
.8288	84 b7		sty $b7		        STY FNLEN           ; start with an empty filename
.828a	84 90		sty $90		        STY SATUS           ; clear status
.828c	a9 01		lda #$01	        LDA #>STAGE         ; set filename pointer to staging buffer
.828e	85 bc		sta $bc		        STA FNADR+1
.8290	a9 17		lda #$17	        LDA #<STAGE
.8292	85 bb		sta $bb		        STA FNADR
.8294	20 1e 87	jsr $871e	L1      JSR GETCHR          ; get a character
.8297	f0 59		beq $82f2	        BEQ LSHORT          ; no filename given, try load or verify from tape
.8299	c9 20		cmp #$20	        CMP #$20            ; skip leading spaces
.829b	f0 f7		beq $8294	        BEQ L1
.829d	c9 22		cmp #$22	        CMP #$22            ; error if filename doesn't start with a quote
.829f	d0 16		bne $82b7	        BNE LERROR
.82a1	ae 31 02	ldx $0231	        LDX CHRPNT          ; load current char pointer into index reg
.82a4	bd 00 02	lda $0200,x	L3      LDA INBUFF,X        ; load current char from buffer to accumulator
.82a7	f0 49		beq $82f2	        BEQ LSHORT          ; no filename given, try load or verify from tape
.82a9	e8		inx		        INX                 ; next char
.82aa	c9 22		cmp #$22	        CMP #$22            ; is it a quote?
.82ac	f0 0c		beq $82ba	        BEQ L8              ; if so, we've reached the end of the filename
.82ae	91 bb		sta ($bb),y	        STA (FNADR),Y       ; if not, save character in filename buffer
.82b0	e6 b7		inc $b7		        INC FNLEN           ; increment filename length
.82b2	c8		iny		        INY
.82b3	c0 1e		cpy #$1e	        CPY #ESTAGE-STAGE   ; check whether buffer is full
.82b5	90 ed		bcc $82a4	        BCC L3              ; if not, get another character
.82b7	4c 90 80	jmp $8090	LERROR  JMP ERROR           ; if so, handle error
.82ba	8e 31 02	stx $0231	L8      STX CHRPNT          ; set character pointer to the current index
.82bd	20 1e 87	jsr $871e	        JSR GETCHR          ; eat separator between filename and device #
.82c0	f0 30		beq $82f2	        BEQ LSHORT          ; no separator, try to load or verify from tape
.82c2	20 ff 85	jsr $85ff	        JSR GETPAR          ; get device number
.82c5	b0 2b		bcs $82f2	        BCS LSHORT          ; no device # given, try load or verify from tape
.82c7	a5 c1		lda $c1		        LDA TMP0            ; set device number for kernal routines
.82c9	85 ba		sta $ba		        STA FA
.82cb	20 ff 85	jsr $85ff	        JSR GETPAR          ; get start address for load or save in TMP0
.82ce	b0 22		bcs $82f2	        BCS LSHORT          ; no start address, try to load or verify
.82d0	20 38 87	jsr $8738	        JSR COPY12          ; transfer start address to TMP2
.82d3	20 ff 85	jsr $85ff	        JSR GETPAR          ; get end address for save in TMP0
.82d6	b0 3d		bcs $8315	        BCS LDADDR          ; no end address, try to load to given start addr
.82d8	20 dd 86	jsr $86dd	        JSR CRLF            ; new line
.82db	a6 c1		ldx $c1		        LDX TMP0            ; put low byte of end address in X
.82dd	a4 c2		ldy $c2		        LDY TMP0+1          ; put high byte of end address in Y
.82df	ad 32 02	lda $0232	        LDA SAVY            ; confirm that we're doing a save
.82e2	c9 53		cmp #$53	        CMP #"S"
.82e4	d0 d1		bne $82b7	        BNE LERROR          ; if not, error due to too many params
.82e6	a9 00		lda #$00	        LDA #0
.82e8	85 b9		sta $b9		        STA SADD            ; set secondary address to 0
.82ea	a9 c3		lda #$c3	        LDA #TMP2           ; put addr of zero-page pointer to data in A
.82ec	20 d8 ff	jsr $ffd8	        JSR SAVE            ; call kernal save routine
.82ef	4c 61 80	jmp $8061	LSVXIT  JMP STRT            ; back to mainloop
.82f2	ad 32 02	lda $0232	LSHORT  LDA SAVY            ; check which command we received
.82f5	c9 56		cmp #$56	        CMP #"V"
.82f7	f0 06		beq $82ff	        BEQ LOADIT          ; we're doing a verify so don't set A to 0
.82f9	c9 4c		cmp #$4c	        CMP #"L"
.82fb	d0 ba		bne $82b7	        BNE LERROR          ; error due to not enough params for save
.82fd	a9 00		lda #$00	        LDA #0              ; 0 in A signals load, anything else is verify
.82ff	20 d5 ff	jsr $ffd5	LOADIT  JSR LOAD            ; call kernal load routine
.8302	a5 90		lda $90		        LDA SATUS           ; get i/o status
.8304	29 10		and #$10	        AND #$10            ; check bit 5 for checksum error
.8306	f0 e7		beq $82ef	        BEQ LSVXIT          ; if no error go back to mainloop
.8308	ad 32 02	lda $0232	        LDA SAVY            ; ?? not sure what these two lines are for...
.830b	f0 aa		beq $82b7	        BEQ LERROR          ; ?? SAVY will never be 0, so why check?
.830d	a0 28		ldy #$28	        LDY #MSG6-MSGBAS    ; display "ERROR" if checksum didn't match
.830f	20 84 89	jsr $8984	        JSR SNDMSG
.8312	4c 61 80	jmp $8061	        JMP STRT            ; back to mainloop
.8315	a6 c3		ldx $c3		LDADDR  LDX TMP2            ; load address low byte in X
.8317	a4 c4		ldy $c4		        LDY TMP2+1          ; load address high byte in Y
.8319	a9 00		lda #$00	        LDA #0              ; 0 in A signals load
.831b	85 b9		sta $b9		        STA SADD            ; secondary addr 0 means load to addr in X and Y
.831d	f0 d3		beq $82f2	        BEQ LSHORT          ; execute load
.831f	20 9c 87	jsr $879c	FILL    JSR GETDIF          ; start in TMP2, end in STASH, length in STORE
.8322	b0 59		bcs $837d	        BCS AERROR          ; carry set indicates error
.8324	20 ff 85	jsr $85ff	        JSR GETPAR          ; get value to fill in TMP0
.8327	b0 54		bcs $837d	        BCS AERROR          ; carry set indicates error
.8329	20 1e 87	jsr $871e	        JSR GETCHR          ; any more characters triggers an error
.832c	d0 4f		bne $837d	        BNE AERROR
.832e	a0 00		ldy #$00	        LDY #0              ; no offset
.8330	a5 c1		lda $c1		FILLP   LDA TMP0            ; load value to fill in accumulator
.8332	91 c3		sta ($c3),y	        STA (TMP2),Y        ; store fill value in current address
.8334	20 e1 ff	jsr $ffe1	        JSR STOP            ; check for stop key
.8337	f0 08		beq $8341	        BEQ FSTART          ; if pressed, back to main loop
.8339	20 75 87	jsr $8775	        JSR ADDA2           ; increment address
.833c	20 63 87	jsr $8763	        JSR SUB13           ; decrement length
.833f	b0 ef		bcs $8330	        BCS FILLP           ; keep going until length reaches 0
.8341	4c 61 80	jmp $8061	FSTART  JMP STRT            ; back to main loop
.8344	b0 37		bcs $837d	ASSEM   BCS AERROR          ; error if no address given
.8346	20 38 87	jsr $8738	        JSR COPY12          ; copy address to TMP2
.8349	a2 00		ldx #$00	AGET1   LDX #0
.834b	8e 0e 01	stx $010e	        STX U0AA0+1         ; clear byte that mnemonic gets shifted into
.834e	8e 08 01	stx $0108	        STX DIGCNT          ; clear digit count
.8351	20 1e 87	jsr $871e	AGET2   JSR GETCHR          ; get a char
.8354	d0 04		bne $835a	        BNE ALMOR           ; proceed if the character isn't null
.8356	e0 00		cpx #$00	        CPX #0              ; it's null, have read a mnemonic yet?
.8358	f0 e7		beq $8341	        BEQ FSTART          ; if not, silently go back to main loop
.835a	c9 20		cmp #$20	ALMOR   CMP #$20            ; skip leading spaces
.835c	f0 eb		beq $8349	        BEQ AGET1
.835e	9d 02 01	sta $0102,x	        STA MNEMW,X         ; put character in mnemonic buffer
.8361	e8		inx		        INX
.8362	e0 03		cpx #$03	        CPX #3              ; have we read 3 characters yet?
.8364	d0 eb		bne $8351	        BNE AGET2           ; if not, get next character
.8366	ca		dex		ASQEEZ  DEX                 ; move to previous char
.8367	30 17		bmi $8380	        BMI AOPRND          ; if we're done with mnemonic, look for operand
.8369	bd 02 01	lda $0102,x	        LDA MNEMW,X         ; get current character
.836c	38		sec		        SEC                 ; pack 3-letter mnemonic into 2 bytes (15 bits)
.836d	e9 3f		sbc #$3f	        SBC #$3F            ; subtract $3F from ascii code so A-Z = 2 to 27
.836f	a0 05		ldy #$05	        LDY #$05            ; letters now fit in 5 bits; shift them out
.8371	4a		lsr a		ASHIFT  LSR A               ;   into the first two bytes of the inst buffer
.8372	6e 0e 01	ror $010e	        ROR U0AA0+1         ; catch the low bit from accumulator in right byte
.8375	6e 0d 01	ror $010d	        ROR U0AA0           ; catch the low bit from right byte in left byte
.8378	88		dey		        DEY                 ; count down bits
.8379	d0 f6		bne $8371	        BNE ASHIFT          ; keep looping until we reach zero
.837b	f0 e9		beq $8366	        BEQ ASQEEZ          ; unconditional branch to handle next char
.837d	4c 90 80	jmp $8090	AERROR  JMP ERROR           ; handle error
.8380	a2 02		ldx #$02	AOPRND  LDX #2              ; mnemonic is in first two bytes so start at third
.8382	ad 08 01	lda $0108	ASCAN   LDA DIGCNT          ; did we find address digits last time?
.8385	d0 2d		bne $83b4	        BNE AFORM1          ; if so, look for mode chars
.8387	20 27 86	jsr $8627	        JSR RDVAL           ; otherwise, look for an address
.838a	f0 25		beq $83b1	        BEQ AFORM0          ; we didn't find an address, look for characters
.838c	b0 ef		bcs $837d	        BCS AERROR          ; carry flag indicates error
.838e	a9 24		lda #$24	        LDA #"$"
.8390	9d 0d 01	sta $010d,x	        STA U0AA0,X         ; prefix addresses with $
.8393	e8		inx		        INX                 ; next position in buffer
.8394	a0 04		ldy #$04	        LDY #4              ; non-zero page addresses are 4 hex digits
.8396	ad 0a 01	lda $010a	        LDA NUMBIT          ; check numeric base in which address was given
.8399	c9 08		cmp #$08	        CMP #8              ; for addresses given in octal or binary
.839b	90 05		bcc $83a2	        BCC AADDR           ;   use only the high byte to determine page
.839d	cc 08 01	cpy $0108	        CPY DIGCNT          ; for decimal or hex, force non-zero page addressing
.83a0	f0 06		beq $83a8	        BEQ AFILL0          ;   if address was given with four digits or more
.83a2	a5 c2		lda $c2		AADDR   LDA TMP0+1          ; check whether high byte of address is zero
.83a4	d0 02		bne $83a8	        BNE AFILL0          ; non-zero high byte means we're not in zero page
.83a6	a0 02		ldy #$02	        LDY #2              ; if it's in zero page, addr is 2 hex digits
.83a8	a9 30		lda #$30	AFILL0  LDA #$30            ; use 0 as placeholder for each hex digit in addr
.83aa	9d 0d 01	sta $010d,x	AFIL0L  STA U0AA0,X         ; put placeholder in assembly buffer
.83ad	e8		inx		        INX                 ; move to next byte in buffer
.83ae	88		dey		        DEY                 ; decrement number of remaining digits
.83af	d0 f9		bne $83aa	        BNE AFIL0L          ; loop until all digits have been placed
.83b1	ce 31 02	dec $0231	AFORM0  DEC CHRPNT          ; non-numeric input; back 1 char to see what it was
.83b4	20 1e 87	jsr $871e	AFORM1  JSR GETCHR          ; get next character
.83b7	f0 0e		beq $83c7	        BEQ AESCAN          ; if there is none, we're finished scanning
.83b9	c9 20		cmp #$20	        CMP #$20            ; skip spaces
.83bb	f0 c5		beq $8382	        BEQ ASCAN
.83bd	9d 0d 01	sta $010d,x	        STA U0AA0,X         ; store character in assembly buffer
.83c0	e8		inx		        INX                 ; move to next byte in buffer
.83c1	e0 0a		cpx #$0a	        CPX #U0AAE-U0AA0    ; is instruction buffer full?
.83c3	90 bd		bcc $8382	        BCC ASCAN           ; if not, keep scanning
.83c5	b0 b6		bcs $837d	        BCS AERROR          ; error if buffer is full
.83c7	8e 2f 02	stx $022f	AESCAN  STX STORE           ; save number of bytes in assembly buffer
.83ca	a2 00		ldx #$00	        LDX #0              ; start at opcode $00 and check every one until
.83cc	8e 06 01	stx $0106	        STX OPCODE          ;   we find one that matches our criteria
.83cf	a2 00		ldx #$00	ATRYOP  LDX #0
.83d1	8e 33 02	stx $0233	        STX U9F             ; reset index into work buffer
.83d4	ad 06 01	lda $0106	        LDA OPCODE
.83d7	20 8e 85	jsr $858e	        JSR INSTXX          ; look up instruction format for current opcode
.83da	ae 00 01	ldx $0100	        LDX ACMD            ; save addressing command for later
.83dd	8e 30 02	stx $0230	        STX STORE+1
.83e0	aa		tax		        TAX                 ; use current opcode as index
.83e1	bd 63 8a	lda $8a63,x	        LDA MNEMR,X         ; check right byte of compressed mnemonic
.83e4	20 b5 84	jsr $84b5	        JSR CHEKOP
.83e7	bd 23 8a	lda $8a23,x	        LDA MNEML,X         ; check left byte of compressed mnemonic
.83ea	20 b5 84	jsr $84b5	        JSR CHEKOP
.83ed	a2 06		ldx #$06	        LDX #6              ; 6 possible characters to check against operand
.83ef	e0 03		cpx #$03	TRYIT   CPX #3              ; are we on character 3?
.83f1	d0 14		bne $8407	        BNE TRYMOD          ; if not, check operand characters
.83f3	ac 01 01	ldy $0101	        LDY LENGTH          ; otherwise, check number of bytes in operand
.83f6	f0 0f		beq $8407	        BEQ TRYMOD          ; if zero, check operand characters
.83f8	ad 00 01	lda $0100	TRYAD   LDA ACMD            ; otherwise, look for an address
.83fb	c9 e8		cmp #$e8	        CMP #$E8            ; special case for relative addressing mode
.83fd	a9 30		lda #$30	        LDA #$30            ; '0' is the digit placeholder we're looking for
.83ff	b0 1e		bcs $841f	        BCS TRY4B           ; ACMD >= $E8 indicates relative addressing
.8401	20 b2 84	jsr $84b2	        JSR CHEK2B          ; ACMD < $E8 indicates normal addressing
.8404	88		dey		        DEY                 ; consume byte
.8405	d0 f1		bne $83f8	        BNE TRYAD           ; check for 2 more digits if not zero-page
.8407	0e 00 01	asl $0100	TRYMOD  ASL ACMD            ; shift a bit out of the addressing command
.840a	90 0e		bcc $841a	        BCC UB4DF           ; if it's zero, skip checking current character
.840c	bd 16 8a	lda $8a16,x	        LDA CHAR1-1,X
.840f	20 b5 84	jsr $84b5	        JSR CHEKOP          ; otherwise first character against operand
.8412	bd 1c 8a	lda $8a1c,x	        LDA CHAR2-1,X       ; get second character to check
.8415	f0 03		beq $841a	        BEQ UB4DF           ; if it's zero, skip checking it
.8417	20 b5 84	jsr $84b5	        JSR CHEKOP          ; otherwise check it against hte operand
.841a	ca		dex		UB4DF   DEX                 ; move to next character
.841b	d0 d2		bne $83ef	        BNE TRYIT           ; repeat tests
.841d	f0 06		beq $8425	        BEQ TRYBRAN
.841f	20 b2 84	jsr $84b2	TRY4B   JSR CHEK2B          ; check for 4 digit address placeholder
.8422	20 b2 84	jsr $84b2	        JSR CHEK2B          ;   by checking for 2 digits twice
.8425	ad 2f 02	lda $022f	TRYBRAN LDA STORE           ; get number of bytes in assembly buffer
.8428	cd 33 02	cmp $0233	        CMP U9F             ; more bytes left to check?
.842b	f0 03		beq $8430	        BEQ ABRAN           ; if not, we've found a match; build instruction
.842d	4c c2 84	jmp $84c2	        JMP BUMPOP          ; if so, this opcode doesn't match; try the next
.8430	ac 01 01	ldy $0101	ABRAN   LDY LENGTH          ; get number of bytes in operand
.8433	f0 32		beq $8467	        BEQ A1BYTE          ; if none, just output the opcode
.8435	ad 30 02	lda $0230	        LDA STORE+1         ; otherwise check the address format
.8438	c9 9d		cmp #$9d	        CMP #$9D            ; is it a relative branch?
.843a	d0 23		bne $845f	        BNE OBJPUT          ; if not, skip relative branch calculation
.843c	a5 c1		lda $c1		        LDA TMP0            ; calculate the difference between the current
.843e	e5 c3		sbc $c3		        SBC TMP2            ;   address and the branch target (low byte)
.8440	aa		tax		        TAX                 ; save it in X
.8441	a5 c2		lda $c2		        LDA TMP0+1          ; borrow from the high byte if necessary
.8443	e5 c4		sbc $c4		        SBC TMP2+1
.8445	90 08		bcc $844f	        BCC ABBACK          ; if result is negative, we're branching back
.8447	d0 66		bne $84af	        BNE SERROR          ; high bytes must be equal when branching forward
.8449	e0 82		cpx #$82	        CPX #$82            ; difference between low bytes must be < 130
.844b	b0 62		bcs $84af	        BCS SERROR          ; error if the address is too far away
.844d	90 08		bcc $8457	        BCC ABRANX
.844f	a8		tay		ABBACK  TAY                 ; when branching backward high byte of target must
.8450	c8		iny		        INY                 ;   be 1 less than high byte of current address
.8451	d0 5c		bne $84af	        BNE SERROR          ; if not, it's too far away
.8453	e0 82		cpx #$82	        CPX #$82            ; difference between low bytes must be < 130
.8455	90 58		bcc $84af	        BCC SERROR          ; if not, it's too far away
.8457	ca		dex		ABRANX  DEX                 ; adjust branch target relative to the
.8458	ca		dex		        DEX                 ;   instruction following this one
.8459	8a		txa		        TXA
.845a	ac 01 01	ldy $0101	        LDY LENGTH          ; load length of operand
.845d	d0 03		bne $8462	        BNE OBJP2           ; don't use the absolute address
.845f	b9 c0 00	lda $00c0,y	OBJPUT  LDA TMP0-1,Y        ; get the operand
.8462	91 c3		sta ($c3),y	OBJP2   STA (TMP2),Y        ; store it after the opcode
.8464	88		dey		        DEY
.8465	d0 f8		bne $845f	        BNE OBJPUT          ; copy the other byte of operand if there is one
.8467	ad 06 01	lda $0106	A1BYTE  LDA OPCODE          ; put opcode into instruction
.846a	91 c3		sta ($c3),y	        STA (TMP2),Y
.846c	20 dd 86	jsr $86dd	        JSR CRLF            ; carriage return
.846f	a9 91		lda #$91	        LDA #$91            ; back up one line
.8471	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8474	a0 2e		ldy #$2e	        LDY #MSG7-MSGBAS    ; "A " prefix
.8476	20 71 89	jsr $8971	        JSR SNDCLR          ; clear line
.8479	20 10 85	jsr $8510	        JSR DISLIN          ; disassemble the instruction we just assembled
.847c	ee 01 01	inc $0101	        INC LENGTH          ; instruction length = operand length + 1 byte
.847f	ad 01 01	lda $0101	        LDA LENGTH          ;   for the opcode
.8482	20 77 87	jsr $8777	        JSR BUMPAD2         ; increment address by length of instruction
.8485	a9 41		lda #$41	        LDA #"A"            ; stuff keyboard buffer with next assemble command:
.8487	8d 77 02	sta $0277	        STA KEYD            ;   "A XXXX " where XXXX is the next address
.848a	a9 20		lda #$20	        LDA #" "            ;   after the previously assembled instruction
.848c	8d 78 02	sta $0278	        STA KEYD+1
.848f	8d 7d 02	sta $027d	        STA KEYD+6
.8492	a5 c4		lda $c4		        LDA TMP2+1          ; convert high byte of next address to hex
.8494	20 06 87	jsr $8706	        JSR ASCTWO
.8497	8d 79 02	sta $0279	        STA KEYD+2          ; put it in the keyboard buffer
.849a	8e 7a 02	stx $027a	        STX KEYD+3
.849d	a5 c3		lda $c3		        LDA TMP2            ; convert low byte of next address to hex
.849f	20 06 87	jsr $8706	        JSR ASCTWO
.84a2	8d 7b 02	sta $027b	        STA KEYD+4          ; put it in the keyboard buffer
.84a5	8e 7c 02	stx $027c	        STX KEYD+5
.84a8	a9 07		lda #$07	        LDA #7              ; set number of chars in keyboard buffer
.84aa	85 c6		sta $c6		        STA NDX
.84ac	4c 61 80	jmp $8061	        JMP STRT            ; back to main loop
.84af	4c 90 80	jmp $8090	SERROR  JMP ERROR           ; handle error
.84b2	20 b5 84	jsr $84b5	CHEK2B  JSR CHEKOP          ; check two bytes against value in accumulator
.84b5	8e 05 01	stx $0105	CHEKOP  STX SAVX            ; stash X
.84b8	ae 33 02	ldx $0233	        LDX U9F             ; get current index into work buffer
.84bb	dd 0d 01	cmp $010d,x	        CMP U0AA0,X         ; check whether this opcode matches the buffer
.84be	f0 0a		beq $84ca	        BEQ OPOK            ;   matching so far, check the next criteria
.84c0	68		pla		        PLA                 ; didn't match, so throw away return address
.84c1	68		pla		        PLA                 ;   on the stack because we're starting over
.84c2	ee 06 01	inc $0106	BUMPOP  INC OPCODE          ; check the next opcode
.84c5	f0 e8		beq $84af	        BEQ SERROR          ; error if we tried every opcode and none fit
.84c7	4c cf 83	jmp $83cf	        JMP ATRYOP          ; start over with new opcode
.84ca	ee 33 02	inc $0233	OPOK    INC U9F             ; opcode matches so far; check the next criteria
.84cd	ae 05 01	ldx $0105	        LDX SAVX            ; restore X
.84d0	60		rts		        RTS
.84d1	b0 08		bcs $84db	DISASS  BCS DIS0AD          ; if no address was given, start from last address
.84d3	20 38 87	jsr $8738	        JSR COPY12          ; copy start address to TMP2
.84d6	20 ff 85	jsr $85ff	        JSR GETPAR          ; get end address in TMP0
.84d9	90 06		bcc $84e1	        BCC DIS2AD          ; if one was given, skip default
.84db	a9 14		lda #$14	DIS0AD  LDA #$14            ; disassemble 14 bytes by default
.84dd	85 c1		sta $c1		        STA TMP0            ; store length in TMP0
.84df	d0 05		bne $84e6	        BNE DISGO           ; skip length calculation
.84e1	20 41 87	jsr $8741	DIS2AD  JSR SUB12           ; calculate number of bytes between start and end
.84e4	90 1f		bcc $8505	        BCC DERROR          ; error if end address is before start address
.84e6	20 6b 89	jsr $896b	DISGO   JSR CLINE           ; clear the current line
.84e9	20 e1 ff	jsr $ffe1	        JSR STOP            ; check for stop key
.84ec	f0 14		beq $8502	        BEQ DISEXIT         ; exit early if pressed
.84ee	20 08 85	jsr $8508	        JSR DSOUT1          ; output disassembly prefix ". "
.84f1	ee 01 01	inc $0101	        INC LENGTH
.84f4	ad 01 01	lda $0101	        LDA LENGTH          ; add length of last instruction to start address
.84f7	20 77 87	jsr $8777	        JSR BUMPAD2
.84fa	ad 01 01	lda $0101	        LDA LENGTH          ; subtract length of last inst from end address
.84fd	20 51 87	jsr $8751	        JSR SUBA2
.8500	b0 e4		bcs $84e6	        BCS DISGO
.8502	4c 61 80	jmp $8061	DISEXIT JMP STRT            ; back to mainloop
.8505	4c 90 80	jmp $8090	DERROR  JMP ERROR
.8508	a9 2e		lda #$2e	DSOUT1  LDA #"."            ; output ". " prefix to allow edit and reassemble
.850a	20 a0 1e	jsr $1ea0	        JSR CHROUT
.850d	20 d5 86	jsr $86d5	        JSR SPACE
.8510	20 c8 86	jsr $86c8	DISLIN  JSR SHOWAD          ; show the address of the instruction
.8513	20 d5 86	jsr $86d5	        JSR SPACE           ; insert a space
.8516	a0 00		ldy #$00	        LDY #0              ; no offset
.8518	b1 c3		lda ($c3),y	        LDA (TMP2),Y        ; load operand of current instruction
.851a	20 8e 85	jsr $858e	        JSR INSTXX          ; get mnemonic and addressing mode for opcode
.851d	48		pha		        PHA                 ; save index into mnemonic table
.851e	ae 01 01	ldx $0101	        LDX LENGTH          ; get length of operand
.8521	e8		inx		        INX                 ; add 1 byte for opcode
.8522	ca		dex		DSBYT   DEX                 ; decrement index
.8523	10 0e		bpl $8533	        BPL DSHEX           ; show hex for byte being disassembled
.8525	8c 32 02	sty $0232	        STY SAVY            ; save index
.8528	a0 30		ldy #$30	        LDY #MSG8-MSGBAS    ; skip 3 spaces
.852a	20 84 89	jsr $8984	        JSR SNDMSG
.852d	ac 32 02	ldy $0232	        LDY SAVY            ; restore index
.8530	4c 38 85	jmp $8538	        JMP NXBYT
.8533	b1 c3		lda ($c3),y	DSHEX   LDA (TMP2),Y        ; show hex for byte
.8535	20 d2 86	jsr $86d2	        JSR WRBYTE
.8538	c8		iny		NXBYT   INY                 ; next byte
.8539	c0 03		cpy #$03	        CPY #3              ; have we output 3 bytes yet?
.853b	90 e5		bcc $8522	        BCC DSBYT           ; if not, loop
.853d	68		pla		        PLA                 ; restore index into mnemonic table
.853e	a2 03		ldx #$03	        LDX #3              ; 3 letters in mnemonic
.8540	20 d6 85	jsr $85d6	        JSR PROPXX          ; print mnemonic
.8543	a2 06		ldx #$06	        LDX #6              ; 6 possible address mode character combos
.8545	e0 03		cpx #$03	PRADR1  CPX #3              ; have we checked the third combo yet?
.8547	d0 16		bne $855f	        BNE PRADR3          ; if so, output the leading characters
.8549	ac 01 01	ldy $0101	        LDY LENGTH          ; get the length of the operand
.854c	f0 11		beq $855f	        BEQ PRADR3          ; if it's zero, there's no operand to print
.854e	ad 00 01	lda $0100	PRADR2  LDA ACMD            ; otherwise, get the addressing mode
.8551	c9 e8		cmp #$e8	        CMP #$E8            ; check for relative addressing
.8553	08		php		        PHP                 ; save result of check
.8554	b1 c3		lda ($c3),y	        LDA (TMP2),Y        ; get the operand
.8556	28		plp		        PLP                 ; restore result of check
.8557	b0 1d		bcs $8576	        BCS RELAD           ; handle a relative address
.8559	20 f6 86	jsr $86f6	        JSR WRTWO           ; output digits from address
.855c	88		dey		        DEY
.855d	d0 ef		bne $854e	        BNE PRADR2          ; repeat for next byte of operand, if there is one
.855f	0e 00 01	asl $0100	PRADR3  ASL ACMD            ; check whether addr mode uses the current char
.8562	90 0e		bcc $8572	        BCC PRADR4          ; if not, skip it
.8564	bd 16 8a	lda $8a16,x	        LDA CHAR1-1,X       ; look up the first char in the table
.8567	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; print first char
.856a	bd 1c 8a	lda $8a1c,x	        LDA CHAR2-1,X       ; look up the second char in the table
.856d	f0 03		beq $8572	        BEQ PRADR4          ; if there's no second character, skip it
.856f	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; print second char
.8572	ca		dex		PRADR4  DEX                 ; next potential address mode character
.8573	d0 d0		bne $8545	        BNE PRADR1          ; loop if we haven't checked them all yet
.8575	60		rts		        RTS                 ; back to caller
.8576	20 82 85	jsr $8582	RELAD   JSR UB64D           ; calculate absolute address from relative
.8579	18		clc		        CLC
.857a	69 01		adc #$01	        ADC #1              ; adjust address relative to next instruction
.857c	d0 01		bne $857f	        BNE RELEND          ; don't increment high byte unless we overflowed
.857e	e8		inx		        INX                 ; increment high byte
.857f	4c cc 86	jmp $86cc	RELEND  JMP WRADDR          ; print address
.8582	a6 c4		ldx $c4		UB64D   LDX TMP2+1          ; get high byte of current address
.8584	a8		tay		        TAY                 ; is relative address positive or negative?
.8585	10 01		bpl $8588	        BPL RELC2           ; if positive, leave high byte alone
.8587	ca		dex		        DEX                 ; if negative, decrement high byte
.8588	65 c3		adc $c3		RELC2   ADC TMP2            ; add relative address to low byte
.858a	90 01		bcc $858d	        BCC RELC3           ; if there's no carry, we're done
.858c	e8		inx		        INX                 ; if there's a carry, increment the high byte
.858d	60		rts		RELC3   RTS
.858e	a8		tay		INSTXX  TAY                 ; stash opcode in accumulator in Y for later
.858f	4a		lsr a		        LSR A               ; is opcode even or odd?
.8590	90 0b		bcc $859d	        BCC IEVEN
.8592	4a		lsr a		        LSR A
.8593	b0 17		bcs $85ac	        BCS ERR             ; invalid opcodes XXXXXX11
.8595	c9 22		cmp #$22	        CMP #$22
.8597	f0 13		beq $85ac	        BEQ ERR             ; invalid opcode 10001001
.8599	29 07		and #$07	        AND #$07            ; mask bits to 10000XXX
.859b	09 80		ora #$80	        ORA #$80
.859d	4a		lsr a		IEVEN   LSR A               ; LSB determines whether to use left/right nybble
.859e	aa		tax		        TAX                 ; get format index using remaining high bytes
.859f	bd c5 89	lda $89c5,x	        LDA MODE,X
.85a2	b0 04		bcs $85a8	        BCS RTMODE          ; look at left or right nybble based on carry bit
.85a4	4a		lsr a		        LSR A               ; if carry = 0, use left nybble
.85a5	4a		lsr a		        LSR A
.85a6	4a		lsr a		        LSR A
.85a7	4a		lsr a		        LSR A
.85a8	29 0f		and #$0f	RTMODE  AND #$0F            ; if carry = 1, use right nybble
.85aa	d0 04		bne $85b0	        BNE GETFMT
.85ac	a0 80		ldy #$80	ERR     LDY #$80            ; substitute 10000000 for invalid opcodes
.85ae	a9 00		lda #$00	        LDA #0
.85b0	aa		tax		GETFMT  TAX
.85b1	bd 09 8a	lda $8a09,x	        LDA MODE2,X         ; lookup operand format using selected nybble
.85b4	8d 00 01	sta $0100	        STA ACMD            ; save for later use
.85b7	29 03		and #$03	        AND #$03            ; lower 2 bits indicate number of bytes in operand
.85b9	8d 01 01	sta $0101	        STA LENGTH
.85bc	98		tya		        TYA                 ; restore original opcode
.85bd	29 8f		and #$8f	        AND #$8F            ; mask bits to X000XXXX
.85bf	aa		tax		        TAX                 ; save it
.85c0	98		tya		        TYA                 ; restore original opcode
.85c1	a0 03		ldy #$03	        LDY #3
.85c3	e0 8a		cpx #$8a	        CPX #$8A            ; check if opcode = 1XXX1010
.85c5	f0 0b		beq $85d2	        BEQ GTFM4
.85c7	4a		lsr a		GTFM2   LSR A               ; transform opcode into index for mnemonic table
.85c8	90 08		bcc $85d2	        BCC GTFM4
.85ca	4a		lsr a		        LSR A               ; opcodes transformed as follows:
.85cb	4a		lsr a		GTFM3   LSR A               ; 1XXX1010->00101XXX
.85cc	09 20		ora #$20	        ORA #$20            ; XXXYYY01->00111XXX
.85ce	88		dey		        DEY                 ; XXXYYY10->00111XXX
.85cf	d0 fa		bne $85cb	        BNE GTFM3           ; XXXYY100->00110XXX
.85d1	c8		iny		        INY                 ; XXXXX000->000XXXXX
.85d2	88		dey		GTFM4   DEY
.85d3	d0 f2		bne $85c7	        BNE GTFM2
.85d5	60		rts		        RTS
.85d6	a8		tay		PROPXX  TAY                 ; use index in accumulator to look up mnemonic
.85d7	b9 23 8a	lda $8a23,y	        LDA MNEML,Y         ;   and place a temporary copy in STORE
.85da	8d 2f 02	sta $022f	        STA STORE
.85dd	b9 63 8a	lda $8a63,y	        LDA MNEMR,Y
.85e0	8d 30 02	sta $0230	        STA STORE+1
.85e3	a9 00		lda #$00	PRMN1   LDA #0              ; clear accumulator
.85e5	a0 05		ldy #$05	        LDY #$05            ; shift 5 times
.85e7	0e 30 02	asl $0230	PRMN2   ASL STORE+1         ; shift right byte
.85ea	2e 2f 02	rol $022f	        ROL STORE           ; rotate bits from right byte into left byte
.85ed	2a		rol a		        ROL A               ; rotate bits from left byte into accumulator
.85ee	88		dey		        DEY                 ; next bit
.85ef	d0 f6		bne $85e7	        BNE PRMN2           ; loop until all bits shifted
.85f1	69 3f		adc #$3f	        ADC #$3F            ; calculate ascii code for letter by adding to '?'
.85f3	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output letter
.85f6	ca		dex		        DEX                 ; next letter
.85f7	d0 ea		bne $85e3	        BNE PRMN1           ; loop until all 3 letters are output
.85f9	4c d5 86	jmp $86d5	        JMP SPACE           ; output space
.85fc	ce 31 02	dec $0231	RDPAR   DEC CHRPNT          ; back up one char
.85ff	20 27 86	jsr $8627	GETPAR  JSR RDVAL           ; read the value
.8602	b0 17		bcs $861b	        BCS GTERR           ; carry set indicates error
.8604	20 1b 87	jsr $871b	        JSR GOTCHR          ; check previous character
.8607	d0 0a		bne $8613	        BNE CKTERM          ; if it's not null, check if it's a valid separator
.8609	ce 31 02	dec $0231	        DEC CHRPNT          ; back up one char
.860c	ad 08 01	lda $0108	        LDA DIGCNT          ; get number of digits read
.860f	d0 11		bne $8622	        BNE GETGOT          ; found some digits
.8611	f0 0d		beq $8620	        BEQ GTNIL           ; didn't find any digits
.8613	c9 20		cmp #$20	CKTERM  CMP #$20            ; space or comma are valid separators
.8615	f0 0b		beq $8622	        BEQ GETGOT          ; anything else is an error
.8617	c9 2c		cmp #$2c	        CMP #","
.8619	f0 07		beq $8622	        BEQ GETGOT
.861b	68		pla		GTERR   PLA                 ; encountered error
.861c	68		pla		        PLA                 ; get rid of command vector pushed on stack
.861d	4c 90 80	jmp $8090	        JMP ERROR           ; handle error
.8620	38		sec		GTNIL   SEC                 ; set carry to indicate no parameter found
>8621	24				        .BYTE $24           ; BIT ZP opcode consumes next byte (CLC)
.8622	18		clc		GETGOT  CLC                 ; clear carry to indicate paremeter returned
.8623	ad 08 01	lda $0108	        LDA DIGCNT          ; return number of digits in A
.8626	60		rts		        RTS                 ; return to address pushed from vector table
.8627	a9 00		lda #$00	RDVAL   LDA #0              ; clear temp
.8629	85 c1		sta $c1		        STA TMP0
.862b	85 c2		sta $c2		        STA TMP0+1
.862d	8d 08 01	sta $0108	        STA DIGCNT          ; clear digit counter
.8630	8a		txa		        TXA                 ; save X and Y
.8631	48		pha		        PHA
.8632	98		tya		        TYA
.8633	48		pha		        PHA
.8634	20 1e 87	jsr $871e	RDVMOR  JSR GETCHR          ; get next character from input buffer
.8637	f0 1e		beq $8657	        BEQ RDNILK          ; null at end of buffer
.8639	c9 20		cmp #$20	        CMP #$20            ; skip spaces
.863b	f0 f7		beq $8634	        BEQ RDVMOR
.863d	a2 03		ldx #$03	        LDX #3              ; check numeric base [$+&%]
.863f	dd b6 8a	cmp $8ab6,x	GNMODE  CMP HIKEY,X
.8642	f0 07		beq $864b	        BEQ GOTMOD          ; got a match, set up base
.8644	ca		dex		        DEX
.8645	10 f8		bpl $863f	        BPL GNMODE          ; check next base
.8647	e8		inx		        INX                 ; default to hex
.8648	ce 31 02	dec $0231	        DEC CHRPNT          ; back up one character
.864b	bc db 8a	ldy $8adb,x	GOTMOD  LDY MODTAB,X        ; get base value
.864e	bd df 8a	lda $8adf,x	        LDA LENTAB,X        ; get bits per digit
.8651	8d 0a 01	sta $010a	        STA NUMBIT          ; store bits per digit
.8654	20 1e 87	jsr $871e	NUDIG   JSR GETCHR          ; get next char in A
.8657	f0 63		beq $86bc	RDNILK  BEQ RDNIL           ; end of number if no more characters
.8659	38		sec		        SEC
.865a	e9 30		sbc #$30	        SBC #$30            ; subtract ascii value of 0 to get numeric value
.865c	90 5e		bcc $86bc	        BCC RDNIL           ; end of number if character was less than 0
.865e	c9 0a		cmp #$0a	        CMP #$0A
.8660	90 06		bcc $8668	        BCC DIGMOR          ; not a hex digit if less than A
.8662	e9 07		sbc #$07	        SBC #$07            ; 7 chars between ascii 9 and A, so subtract 7
.8664	c9 10		cmp #$10	        CMP #$10            ; end of number if char is greater than F
.8666	b0 54		bcs $86bc	        BCS RDNIL
.8668	8d 09 01	sta $0109	DIGMOR  STA INDIG           ; store the digit
.866b	cc 09 01	cpy $0109	        CPY INDIG           ; compare base with the digit
.866e	90 4a		bcc $86ba	        BCC RDERR           ; error if the digit >= the base
.8670	f0 48		beq $86ba	        BEQ RDERR
.8672	ee 08 01	inc $0108	        INC DIGCNT          ; increment the number of digits
.8675	c0 0a		cpy #$0a	        CPY #10
.8677	d0 0a		bne $8683	        BNE NODECM          ; skip the next part if not using base 10
.8679	a2 01		ldx #$01	        LDX #1
.867b	b5 c1		lda $c1,x	DECLP1  LDA TMP0,X          ; stash the previous 16-bit value for later use
.867d	9d 0b 01	sta $010b,x	        STA STASH,X
.8680	ca		dex		        DEX
.8681	10 f8		bpl $867b	        BPL DECLP1
.8683	ae 0a 01	ldx $010a	NODECM  LDX NUMBIT          ; number of bits to shift
.8686	06 c1		asl $c1		TIMES2  ASL TMP0            ; shift 16-bit value by specified number of bits
.8688	26 c2		rol $c2		        ROL TMP0+1
.868a	b0 2e		bcs $86ba	        BCS RDERR           ; error if we overflowed 16 bits
.868c	ca		dex		        DEX
.868d	d0 f7		bne $8686	        BNE TIMES2          ; shift remaining bits
.868f	c0 0a		cpy #$0a	        CPY #10
.8691	d0 18		bne $86ab	        BNE NODEC2          ; skip the next part if not using base 10
.8693	0e 0b 01	asl $010b	        ASL STASH           ; shift the previous 16-bit value one bit left
.8696	2e 0c 01	rol $010c	        ROL STASH+1
.8699	b0 1f		bcs $86ba	        BCS RDERR           ; error if we overflowed 16 bits
.869b	ad 0b 01	lda $010b	        LDA STASH           ; add shifted previous value to current value
.869e	65 c1		adc $c1		        ADC TMP0
.86a0	85 c1		sta $c1		        STA TMP0
.86a2	ad 0c 01	lda $010c	        LDA STASH+1
.86a5	65 c2		adc $c2		        ADC TMP0+1
.86a7	85 c2		sta $c2		        STA TMP0+1
.86a9	b0 0f		bcs $86ba	        BCS RDERR           ; error if we overflowed 16 bits
.86ab	18		clc		NODEC2  CLC
.86ac	ad 09 01	lda $0109	        LDA INDIG           ; load current digit
.86af	65 c1		adc $c1		        ADC TMP0            ; add current digit to low byte
.86b1	85 c1		sta $c1		        STA TMP0            ; and store result back in low byte
.86b3	8a		txa		        TXA                 ; A=0
.86b4	65 c2		adc $c2		        ADC TMP0+1          ; add carry to high byte
.86b6	85 c2		sta $c2		        STA TMP0+1          ; and store result back in high byte
.86b8	90 9a		bcc $8654	        BCC NUDIG           ; get next digit if we didn't overflow
.86ba	38		sec		RDERR   SEC                 ; set carry to indicate error
>86bb	24				        .BYTE $24           ; BIT ZP opcode consumes next byte (CLC)
.86bc	18		clc		RDNIL   CLC                 ; clear carry to indicate success
.86bd	8c 0a 01	sty $010a	        STY NUMBIT          ; save base of number
.86c0	68		pla		        PLA                 ; restore X and Y
.86c1	a8		tay		        TAY
.86c2	68		pla		        PLA
.86c3	aa		tax		        TAX
.86c4	ad 08 01	lda $0108	        LDA DIGCNT          ; return number of digits in A
.86c7	60		rts		        RTS
.86c8	a5 c3		lda $c3		SHOWAD  LDA TMP2
.86ca	a6 c4		ldx $c4		        LDX TMP2+1
.86cc	48		pha		WRADDR  PHA                 ; save low byte
.86cd	8a		txa		        TXA                 ; put high byte in A
.86ce	20 f6 86	jsr $86f6	        JSR WRTWO           ; output high byte
.86d1	68		pla		        PLA                 ; restore low byte
.86d2	20 f6 86	jsr $86f6	WRBYTE  JSR WRTWO           ; output byte in A
.86d5	a9 20		lda #$20	SPACE   LDA #$20            ; output space
.86d7	d0 0f		bne $86e8	        BNE FLIP
.86d9	c9 0d		cmp #$0d	CHOUT   CMP #$0D            ; output char with special handling of CR
.86db	d0 0b		bne $86e8	        BNE FLIP
.86dd	a9 0d		lda #$0d	CRLF    LDA #$0D            ; load CR in A
.86df	24 13		bit $13		        BIT $13             ; check default channel
.86e1	10 05		bpl $86e8	        BPL FLIP            ; if high bit is clear output CR only
.86e3	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; otherwise output CR+LF
.86e6	a9 0a		lda #$0a	        LDA #$0A            ; output LF
.86e8	4c a0 1e	jmp $1ea0	FLIP    JMP CHROUT
.86eb	20 dd 86	jsr $86dd	FRESH   JSR CRLF            ; output CR
.86ee	a9 20		lda #$20	        LDA #$20            ; load space in A
.86f0	20 a0 1e	jsr $1ea0	        JSR CHROUT
.86f3	4c 74 89	jmp $8974	        JMP SNCLR
.86f6	8e 05 01	stx $0105	WRTWO   STX SAVX            ; save X
.86f9	20 06 87	jsr $8706	        JSR ASCTWO          ; get hex chars for byte in X (lower) and A (upper)
.86fc	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output upper nybble
.86ff	8a		txa		        TXA                 ; transfer lower to A
.8700	ae 05 01	ldx $0105	        LDX SAVX            ; restore X
.8703	4c a0 1e	jmp $1ea0	        JMP CHROUT          ; output lower nybble
.8706	48		pha		ASCTWO  PHA                 ; save byte
.8707	20 10 87	jsr $8710	        JSR ASCII           ; do low nybble
.870a	aa		tax		        TAX                 ; save in X
.870b	68		pla		        PLA                 ; restore byte
.870c	4a		lsr a		        LSR A               ; shift upper nybble down
.870d	4a		lsr a		        LSR A
.870e	4a		lsr a		        LSR A
.870f	4a		lsr a		        LSR A
.8710	29 0f		and #$0f	ASCII   AND #$0F            ; clear upper nibble
.8712	c9 0a		cmp #$0a	        CMP #$0A            ; if less than A, skip next step
.8714	90 02		bcc $8718	        BCC ASC1
.8716	69 06		adc #$06	        ADC #6              ; skip ascii chars between 9 and A
.8718	69 30		adc #$30	ASC1    ADC #$30            ; add ascii char 0 to value
.871a	60		rts		        RTS
.871b	ce 31 02	dec $0231	GOTCHR  DEC CHRPNT
.871e	8e 05 01	stx $0105	GETCHR  STX SAVX
.8721	ae 31 02	ldx $0231	        LDX CHRPNT          ; get pointer to next char
.8724	bd 00 02	lda $0200,x	        LDA INBUFF,X        ; load next char in A
.8727	f0 06		beq $872f	        BEQ NOCHAR          ; null, :, or ? signal end of buffer
.8729	c9 3a		cmp #$3a	        CMP #":"
.872b	f0 02		beq $872f	        BEQ NOCHAR
.872d	c9 3f		cmp #$3f	        CMP #"?"
.872f	08		php		NOCHAR  PHP
.8730	ee 31 02	inc $0231	        INC CHRPNT          ; next char
.8733	ae 05 01	ldx $0105	        LDX SAVX
.8736	28		plp		        PLP                 ; Z flag will signal last character
.8737	60		rts		        RTS
.8738	a5 c1		lda $c1		COPY12  LDA TMP0            ; low byte
.873a	85 c3		sta $c3		        STA TMP2
.873c	a5 c2		lda $c2		        LDA TMP0+1          ; high byte
.873e	85 c4		sta $c4		        STA TMP2+1
.8740	60		rts		        RTS
.8741	38		sec		SUB12   SEC
.8742	a5 c1		lda $c1		        LDA TMP0            ; subtract low byte
.8744	e5 c3		sbc $c3		        SBC TMP2
.8746	85 c1		sta $c1		        STA TMP0
.8748	a5 c2		lda $c2		        LDA TMP0+1
.874a	e5 c4		sbc $c4		        SBC TMP2+1          ; subtract high byte
.874c	85 c2		sta $c2		        STA TMP0+1
.874e	60		rts		        RTS
.874f	a9 01		lda #$01	SUBA1   LDA #1              ; shortcut to decrement by 1
.8751	8d 05 01	sta $0105	SUBA2   STA SAVX            ; subtrahend in accumulator
.8754	38		sec		        SEC
.8755	a5 c1		lda $c1		        LDA TMP0            ; minuend in low byte
.8757	ed 05 01	sbc $0105	        SBC SAVX
.875a	85 c1		sta $c1		        STA TMP0
.875c	a5 c2		lda $c2		        LDA TMP0+1          ; borrow from high byte
.875e	e9 00		sbc #$00	        SBC #0
.8760	85 c2		sta $c2		        STA TMP0+1
.8762	60		rts		        RTS
.8763	38		sec		SUB13   SEC
.8764	ad 2f 02	lda $022f	        LDA STORE
.8767	e9 01		sbc #$01	        SBC #1              ; decrement low byte
.8769	8d 2f 02	sta $022f	        STA STORE
.876c	ad 30 02	lda $0230	        LDA STORE+1
.876f	e9 00		sbc #$00	        SBC #0              ; borrow from high byte
.8771	8d 30 02	sta $0230	        STA STORE+1
.8774	60		rts		        RTS
.8775	a9 01		lda #$01	ADDA2   LDA #1              ; shortcut to increment by 1
.8777	18		clc		BUMPAD2 CLC
.8778	65 c3		adc $c3		        ADC TMP2            ; add value in accumulator to low byte
.877a	85 c3		sta $c3		        STA TMP2
.877c	90 02		bcc $8780	        BCC BUMPEX
.877e	e6 c4		inc $c4		        INC TMP2+1          ; carry to high byte
.8780	60		rts		BUMPEX  RTS
.8781	38		sec		SUB21   SEC
.8782	a5 c3		lda $c3		        LDA TMP2            ; decrement low byte
.8784	e9 01		sbc #$01	        SBC #1
.8786	85 c3		sta $c3		        STA TMP2
.8788	a5 c4		lda $c4		        LDA TMP2+1          ; borrow from high byte
.878a	e9 00		sbc #$00	        SBC #0
.878c	85 c4		sta $c4		        STA TMP2+1
.878e	60		rts		        RTS
.878f	b0 0a		bcs $879b	COPY1P  BCS CPY1PX          ; do nothing if parameter is empty
.8791	a5 c1		lda $c1		        LDA TMP0            ; copy low byte
.8793	a4 c2		ldy $c2		        LDY TMP0+1          ; copy high byte
.8795	8d 29 02	sta $0229	        STA PCL
.8798	8c 28 02	sty $0228	        STY PCH
.879b	60		rts		CPY1PX  RTS
.879c	b0 23		bcs $87c1	GETDIF  BCS GDIFX           ; exit with error if no parameter given
.879e	20 38 87	jsr $8738	        JSR COPY12          ; save start address in TMP2
.87a1	20 ff 85	jsr $85ff	        JSR GETPAR          ; get end address in TMP0
.87a4	b0 1b		bcs $87c1	        BCS GDIFX           ; exit with error if no parameter given
.87a6	a5 c1		lda $c1		        LDA TMP0            ; save end address in STASH
.87a8	8d 0b 01	sta $010b	        STA STASH
.87ab	a5 c2		lda $c2		        LDA TMP0+1
.87ad	8d 0c 01	sta $010c	        STA STASH+1
.87b0	20 41 87	jsr $8741	        JSR SUB12           ; subtract start address from end address
.87b3	a5 c1		lda $c1		        LDA TMP0
.87b5	8d 2f 02	sta $022f	        STA STORE           ; save difference in STORE
.87b8	a5 c2		lda $c2		        LDA TMP0+1
.87ba	8d 30 02	sta $0230	        STA STORE+1
.87bd	90 02		bcc $87c1	        BCC GDIFX           ; error if start address is after end address
.87bf	18		clc		        CLC                 ; clear carry to indicate success
>87c0	24				        .BYTE $24           ; BIT ZP opcode consumes next byte (SEC)
.87c1	38		sec		GDIFX   SEC                 ; set carry to indicate error
.87c2	60		rts		        RTS
.87c3	20 fc 85	jsr $85fc	CONVRT  JSR RDPAR           ; read a parameter
.87c6	20 eb 86	jsr $86eb	        JSR FRESH           ; next line and clear
.87c9	a9 24		lda #$24	        LDA #"$"            ; output $ sigil for hex
.87cb	20 a0 1e	jsr $1ea0	        JSR CHROUT
.87ce	a5 c1		lda $c1		        LDA TMP0            ; load the 16-bit value entered
.87d0	a6 c2		ldx $c2		        LDX TMP0+1
.87d2	20 cc 86	jsr $86cc	        JSR WRADDR          ; print it in 4 hex digits
.87d5	20 eb 86	jsr $86eb	        JSR FRESH
.87d8	a9 2b		lda #$2b	        LDA #"+"            ; output + sigil for decimal
.87da	20 a0 1e	jsr $1ea0	        JSR CHROUT
.87dd	20 0e 88	jsr $880e	        JSR CVTDEC          ; convert to BCD using hardware mode
.87e0	a9 00		lda #$00	        LDA #0              ; clear digit counter
.87e2	a2 06		ldx #$06	        LDX #6              ; max digits + 1
.87e4	a0 03		ldy #$03	        LDY #3              ; bits per digit - 1
.87e6	20 48 88	jsr $8848	        JSR NMPRNT          ; print result without leading zeros
.87e9	20 eb 86	jsr $86eb	        JSR FRESH           ; next line and clear
.87ec	a9 26		lda #$26	        LDA #"&"            ; print & sigil for octal
.87ee	20 a0 1e	jsr $1ea0	        JSR CHROUT
.87f1	a9 00		lda #$00	        LDA #0              ; clear digit counter
.87f3	a2 08		ldx #$08	        LDX #8              ; max digits + 1
.87f5	a0 02		ldy #$02	        LDY #2              ; bits per digit - 1
.87f7	20 37 88	jsr $8837	        JSR PRINUM          ; output number
.87fa	20 eb 86	jsr $86eb	        JSR FRESH           ; next line and clear
.87fd	a9 25		lda #$25	        LDA #"%"            ; print % sigil for binary
.87ff	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8802	a9 00		lda #$00	        LDA #0              ; clear digit counter
.8804	a2 18		ldx #$18	        LDX #$18            ; max digits + 1
.8806	a0 00		ldy #$00	        LDY #0              ; bits per digit - 1
.8808	20 37 88	jsr $8837	        JSR PRINUM          ; output number
.880b	4c 61 80	jmp $8061	        JMP STRT            ; back to mainloop
.880e	20 38 87	jsr $8738	CVTDEC  JSR COPY12          ; copy value from TMP0 to TMP2
.8811	a9 00		lda #$00	        LDA #0
.8813	a2 02		ldx #$02	        LDX #2              ; clear 3 bytes in work buffer
.8815	9d 0d 01	sta $010d,x	DECML1  STA U0AA0,X
.8818	ca		dex		        DEX
.8819	10 fa		bpl $8815	        BPL DECML1
.881b	a0 10		ldy #$10	        LDY #16             ; 16 bits in input
.881d	08		php		        PHP                 ; save status register
.881e	78		sei		        SEI                 ; make sure no interrupts occur with BCD enabled
.881f	f8		sed		        SED
.8820	06 c3		asl $c3		DECML2  ASL TMP2            ; rotate bytes out of input low byte
.8822	26 c4		rol $c4		        ROL TMP2+1          ; .. into high byte and carry bit
.8824	a2 02		ldx #$02	        LDX #2              ; process 3 bytes
.8826	bd 0d 01	lda $010d,x	DECDBL  LDA U0AA0,X         ; load current value of byte
.8829	7d 0d 01	adc $010d,x	        ADC U0AA0,X         ; add it to itself plus the carry bit
.882c	9d 0d 01	sta $010d,x	        STA U0AA0,X         ; store it back in the same location
.882f	ca		dex		        DEX                 ; decrement byte counter
.8830	10 f4		bpl $8826	        BPL DECDBL          ; loop until all bytes processed
.8832	88		dey		        DEY                 ; decrement bit counter
.8833	d0 eb		bne $8820	        BNE DECML2          ; loop until all bits processed
.8835	28		plp		        PLP                 ; restore processor status
.8836	60		rts		        RTS
.8837	48		pha		PRINUM  PHA                 ; save accumulator
.8838	a5 c1		lda $c1		        LDA TMP0            ; copy input low byte to work buffer
.883a	8d 0f 01	sta $010f	        STA U0AA0+2
.883d	a5 c2		lda $c2		        LDA TMP0+1          ; copy input high byte to work buffer
.883f	8d 0e 01	sta $010e	        STA U0AA0+1
.8842	a9 00		lda #$00	        LDA #0              ; clear overflow byte in work buffer
.8844	8d 0d 01	sta $010d	        STA U0AA0
.8847	68		pla		        PLA                 ; restore accumulator
.8848	8d 08 01	sta $0108	NMPRNT  STA DIGCNT          ; number of digits in accumulator
.884b	8c 0a 01	sty $010a	        STY NUMBIT          ; bits per digit passed in Y register
.884e	ac 0a 01	ldy $010a	DIGOUT  LDY NUMBIT          ; get bits to process
.8851	a9 00		lda #$00	        LDA #0              ; clear accumulator
.8853	0e 0f 01	asl $010f	ROLBIT  ASL U0AA0+2         ; shift bits out of low byte
.8856	2e 0e 01	rol $010e	        ROL U0AA0+1         ; ... into high byte
.8859	2e 0d 01	rol $010d	        ROL U0AA0           ; ... into overflow byte
.885c	2a		rol a		        ROL A               ; ... into accumulator
.885d	88		dey		        DEY                 ; decrement bit counter
.885e	10 f3		bpl $8853	        BPL ROLBIT          ; loop until all bits processed
.8860	a8		tay		        TAY                 ; check whether accumulator is 0
.8861	d0 09		bne $886c	        BNE NZERO           ; if not, print it
.8863	e0 01		cpx #$01	        CPX #1              ; have we output the max number of digits?
.8865	f0 05		beq $886c	        BEQ NZERO           ; if not, print it
.8867	ac 08 01	ldy $0108	        LDY DIGCNT          ; how many digits have we output?
.886a	f0 08		beq $8874	        BEQ ZERSUP          ; skip output if digit is 0
.886c	ee 08 01	inc $0108	NZERO   INC DIGCNT          ; increment digit counter
.886f	09 30		ora #$30	        ORA #$30            ; add numeric value to ascii '0' to get ascii char
.8871	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output character
.8874	ca		dex		ZERSUP  DEX                 ; decrement number of leading zeros
.8875	d0 d7		bne $884e	        BNE DIGOUT          ; next digit
.8877	60		rts		        RTS
.8878	d0 03		bne $887d	DSTAT   BNE CHGDEV          ; if device address was given, use it
.887a	a2 08		ldx #$08	        LDX #8              ; otherwise, default to 8
>887c	2c				        .BYTE $2C           ; absolute BIT opcode consumes next word (LDX TMP0)
.887d	a6 c1		ldx $c1		CHGDEV  LDX TMP0            ; load device address from parameter
.887f	e0 04		cpx #$04	        CPX #4              ; make sure device address is in range 4-31
.8881	90 58		bcc $88db	        BCC IOERR
.8883	e0 20		cpx #$20	        CPX #32
.8885	b0 54		bcs $88db	        BCS IOERR
.8887	86 c1		stx $c1		        STX TMP0
.8889	a9 00		lda #$00	        LDA #0              ; clear status
.888b	85 90		sta $90		        STA SATUS
.888d	85 b7		sta $b7		        STA FNLEN           ; empty filename
.888f	20 1e 87	jsr $871e	        JSR GETCHR          ; get next character
.8892	f0 24		beq $88b8	        BEQ INSTAT1         ; null, display status
.8894	ce 31 02	dec $0231	        DEC CHRPNT          ; back up 1 char
.8897	c9 24		cmp #$24	        CMP #"$"            ; $, display directory
.8899	f0 43		beq $88de	        BEQ DIRECT
.889b	a5 c1		lda $c1		        LDA TMP0            ; command specified device to listen
.889d	20 b1 ff	jsr $ffb1	        JSR LISTEN
.88a0	a9 6f		lda #$6f	        LDA #$6F            ; secondary address 15 (only low nybble used)
.88a2	20 93 ff	jsr $ff93	        JSR SECOND
.88a5	ae 31 02	ldx $0231	DCOMD   LDX CHRPNT          ; get next character from buffer
.88a8	ee 31 02	inc $0231	        INC CHRPNT
.88ab	bd 00 02	lda $0200,x	        LDA INBUFF,X
.88ae	f0 05		beq $88b5	        BEQ INSTAT          ; break out of loop if it's null
.88b0	20 a8 ff	jsr $ffa8	        JSR CIOUT           ; otherwise output it to the serial bus
.88b3	90 f0		bcc $88a5	        BCC DCOMD           ; unconditional loop: CIOUT clears carry before RTS
.88b5	20 ae ff	jsr $ffae	INSTAT  JSR UNLSN           ; command device to unlisten
.88b8	20 dd 86	jsr $86dd	INSTAT1 JSR CRLF            ; new line
.88bb	a5 c1		lda $c1		        LDA TMP0            ; load device address
.88bd	20 b4 ff	jsr $ffb4	        JSR TALK            ; command device to talk
.88c0	a9 6f		lda #$6f	        LDA #$6F            ; secondary address 15 (only low nybble used)
.88c2	20 96 ff	jsr $ff96	        JSR TKSA
.88c5	20 a5 ff	jsr $ffa5	RDSTAT  JSR ACPTR           ; read byte from serial bus
.88c8	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; print it
.88cb	c9 0d		cmp #$0d	        CMP #$0D            ; if the byte is CR, exit loop
.88cd	f0 06		beq $88d5	        BEQ DEXIT
.88cf	a5 90		lda $90		        LDA SATUS           ; check status
.88d1	29 bf		and #$bf	        AND #$BF            ; ignore EOI bit
.88d3	f0 f0		beq $88c5	        BEQ RDSTAT          ; if no errors, read next byte
.88d5	20 ab ff	jsr $ffab	DEXIT   JSR UNTLK           ; command device to stop talking
.88d8	4c 61 80	jmp $8061	        JMP STRT            ; back to mainloop
.88db	4c 90 80	jmp $8090	IOERR   JMP ERROR           ; handle error
.88de	a5 c1		lda $c1		DIRECT  LDA TMP0            ; load device address
.88e0	20 b1 ff	jsr $ffb1	        JSR LISTEN          ; command device to listen
.88e3	a9 f0		lda #$f0	        LDA #$F0            ; secondary address 0 (only low nybble used)
.88e5	20 93 ff	jsr $ff93	        JSR SECOND
.88e8	ae 31 02	ldx $0231	        LDX CHRPNT          ; get index of next character
.88eb	bd 00 02	lda $0200,x	DIR2    LDA INBUFF,X        ; get next character from buffer
.88ee	f0 06		beq $88f6	        BEQ DIR3            ; break if it's null
.88f0	20 a8 ff	jsr $ffa8	        JSR CIOUT           ; send character to device
.88f3	e8		inx		        INX                 ; increment characer index
.88f4	d0 f5		bne $88eb	        BNE DIR2            ; loop if it hasn't wrapped to zero
.88f6	20 ae ff	jsr $ffae	DIR3    JSR UNLSN           ; command device to unlisten
.88f9	20 dd 86	jsr $86dd	        JSR CRLF            ; new line
.88fc	a5 c1		lda $c1		        LDA TMP0            ; load device address
.88fe	48		pha		        PHA                 ; save on stack
.88ff	20 b4 ff	jsr $ffb4	        JSR TALK            ; command device to talk
.8902	a9 60		lda #$60	        LDA #$60            ; secondary address 0 (only low nybble used)
.8904	20 96 ff	jsr $ff96	        JSR TKSA
.8907	a0 03		ldy #$03	        LDY #3              ; read 3 16-bit values from device
.8909	8c 2f 02	sty $022f	DIRLIN  STY STORE           ;   ignore the first 2; 3rd is file size
.890c	20 a5 ff	jsr $ffa5	DLINK   JSR ACPTR           ; read low byte from device
.890f	85 c1		sta $c1		        STA TMP0            ; store it
.8911	a5 90		lda $90		        LDA SATUS           ; check status
.8913	d0 44		bne $8959	        BNE DREXIT          ; exit if error or eof occurred
.8915	20 a5 ff	jsr $ffa5	        JSR ACPTR           ; read high byte from device
.8918	85 c2		sta $c2		        STA TMP0+1          ; store it
.891a	a5 90		lda $90		        LDA SATUS           ; check status
.891c	d0 3b		bne $8959	        BNE DREXIT          ; exit if error or eof cocurred
.891e	ce 2f 02	dec $022f	        DEC STORE           ; decrement byte count
.8921	d0 e9		bne $890c	        BNE DLINK           ; loop if bytes remain
.8923	20 0e 88	jsr $880e	        JSR CVTDEC          ; convert last 16-bit value to decimal
.8926	a9 00		lda #$00	        LDA #0              ; clear digit count
.8928	a2 06		ldx #$06	        LDX #6              ; max 6 digits
.892a	a0 03		ldy #$03	        LDY #3              ; 3 bits per digit
.892c	20 48 88	jsr $8848	        JSR NMPRNT          ; output number
.892f	a9 20		lda #$20	        LDA #" "            ; output space
.8931	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8934	20 a5 ff	jsr $ffa5	DNAME   JSR ACPTR           ; get a filename character from the device
.8937	f0 0a		beq $8943	        BEQ DMORE           ; if it's null, break out of loop
.8939	a6 90		ldx $90		        LDX SATUS           ; check for errors or eof
.893b	d0 1c		bne $8959	        BNE DREXIT          ; if found exit early
.893d	20 a0 1e	jsr $1ea0	        JSR CHROUT          ; output character
.8940	18		clc		        CLC
.8941	90 f1		bcc $8934	        BCC DNAME           ; unconditional branch to read next char
.8943	20 dd 86	jsr $86dd	DMORE   JSR CRLF
.8946	20 e1 ff	jsr $ffe1	        JSR STOP            ; check for stop key
.8949	f0 0e		beq $8959	        BEQ DREXIT          ; exit early if pressed
.894b	20 e4 ff	jsr $ffe4	        JSR GETIN           ; pause if a key was pressed
.894e	f0 05		beq $8955	        BEQ NOPAWS
.8950	20 e4 ff	jsr $ffe4	PAWS    JSR GETIN           ; wait until another key is pressed
.8953	f0 fb		beq $8950	        BEQ PAWS
.8955	a0 02		ldy #$02	NOPAWS  LDY #2
.8957	d0 b0		bne $8909	        BNE DIRLIN          ; unconditional branch to read next file
.8959	20 ab ff	jsr $ffab	DREXIT  JSR UNTLK           ; command device to untalk
.895c	68		pla		        PLA                 ; restore accumulator
.895d	20 b1 ff	jsr $ffb1	        JSR LISTEN          ; command device to listen
.8960	a9 e0		lda #$e0	        LDA #$E0            ; secondary address 0 (only low nybble is used)
.8962	20 93 ff	jsr $ff93	        JSR SECOND
.8965	20 ae ff	jsr $ffae	        JSR UNLSN           ; command device to unlisten
.8968	4c 61 80	jmp $8061	        JMP STRT            ; back to mainloop
.896b	20 dd 86	jsr $86dd	CLINE   JSR CRLF            ; send CR+LF
.896e	4c 74 89	jmp $8974	        JMP SNCLR           ; clear line
.8971	20 84 89	jsr $8984	SNDCLR  JSR SNDMSG
.8974	a0 28		ldy #$28	SNCLR   LDY #$28            ; loop 40 times
.8976	a9 20		lda #$20	SNCLP   LDA #$20            ; output space character
.8978	20 a0 1e	jsr $1ea0	        JSR CHROUT
.897b	a9 14		lda #$14	        LDA #$14            ; output delete character
.897d	20 a0 1e	jsr $1ea0	        JSR CHROUT
.8980	88		dey		        DEY
.8981	d0 f3		bne $8976	        BNE SNCLP
.8983	60		rts		        RTS
.8984	b9 92 89	lda $8992,y	SNDMSG  LDA MSGBAS,Y        ; Y contains offset in msg table
.8987	08		php		        PHP
.8988	29 7f		and #$7f	        AND #$7F            ; strip high bit before output
.898a	20 d9 86	jsr $86d9	        JSR CHOUT
.898d	c8		iny		        INY
.898e	28		plp		        PLP
.898f	10 f3		bpl $8984	        BPL SNDMSG          ; loop until high bit is set
.8991	60		rts		        RTS
=$8992					MSGBAS  =*
>8992	0d				MSG2    .BYTE $0D               ; header for registers
>8993	20 20 20 50 43 20 20 53		        .TEXT "   PC  SR AC XR YR SP   V1.2"
>899b	52 20 41 43 20 58 52 20 59 52 20 53 50 20 20 20
>89ab	56 31 2e 32
>89af	8d				        .BYTE $0D+$80
>89b0	1d bf				MSG3    .BYTE $1D,$3F+$80       ; syntax error: move right, display "?"
>89b2	2e 2e 53 59 53			MSG4    .TEXT "..SYS"           ; SYS call to enter monitor
>89b7	a0				        .BYTE $20+$80
>89b8	3a 92				MSG5    .BYTE $3A,$12+$80       ; ":" then RVS ON for memory ASCII dump
>89ba	20 45 52 52 4f			MSG6    .TEXT " ERRO"           ; I/O error: display " ERROR"
>89bf	d2				        .BYTE "R"+$80
>89c0	41 a0				MSG7    .BYTE $41,$20+$80       ; assemble next instruction: "A " + addr
>89c2	20 20				MSG8    .TEXT "  "              ; pad non-existent byte: skip 3 spaces
>89c4	a0				        .BYTE $20+$80
>89c5	40 02 45 03			MODE    .BYTE $40,$02,$45,$03   ; even opcodes
>89c9	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89cd	30 22 45 33			        .BYTE $30,$22,$45,$33
>89d1	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89d5	40 02 45 33			        .BYTE $40,$02,$45,$33
>89d9	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89dd	40 02 45 b3			        .BYTE $40,$02,$45,$B3
>89e1	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89e5	00 22 44 33			        .BYTE $00,$22,$44,$33
>89e9	d0 8c 44 00			        .BYTE $D0,$8C,$44,$00
>89ed	11 22 44 33			        .BYTE $11,$22,$44,$33
>89f1	d0 8c 44 9a			        .BYTE $D0,$8C,$44,$9A
>89f5	10 22 44 33			        .BYTE $10,$22,$44,$33
>89f9	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>89fd	10 22 44 33			        .BYTE $10,$22,$44,$33
>8a01	d0 08 40 09			        .BYTE $D0,$08,$40,$09
>8a05	62 13 78 a9			        .BYTE $62,$13,$78,$A9   ; opcodes ending in 01
>8a09	00				MODE2   .BYTE $00   ; 000 000    00                  0   error
>8a0a	21				        .BYTE $21   ; 001 000    01      #$00        1   immediate
>8a0b	81				        .BYTE $81   ; 100 000    01      $00         2   zero-page
>8a0c	82				        .BYTE $82   ; 100 000    10      $0000       3   absolute
>8a0d	00				        .BYTE $00   ; 000 000    00                  4   implied
>8a0e	00				        .BYTE $00   ; 000 000    00                  5   accumulator
>8a0f	59				        .BYTE $59   ; 010 110    01      ($00,X)     6   indirect,X
>8a10	4d				        .BYTE $4D   ; 010 011    01      ($00),Y     7   indirect,Y
>8a11	91				        .BYTE $91   ; 100 100    01      $00,X       8   zero-page,X
>8a12	92				        .BYTE $92   ; 100 100    10      $0000,X     9   absolute,X
>8a13	86				        .BYTE $86   ; 100 001    10      $0000,Y     A   absolute,Y
>8a14	4a				        .BYTE $4A   ; 010 010    10      ($0000)     B   indirect
>8a15	85				        .BYTE $85   ; 100 001    01      $00,Y       C   zero-page,Y
>8a16	9d				        .BYTE $9D   ; 100 111    01      $0000*      D   relative
>8a17	2c 29 2c			CHAR1   .BYTE $2C,$29,$2C       ; ","  ")"  ","
>8a1a	23 28 24			        .BYTE $23,$28,$24       ; "#"  "("  "$"
>8a1d	59 00 58			CHAR2   .BYTE $59,$00,$58       ; "Y"   0   "X"
>8a20	24 24 00			        .BYTE $24,$24,$00       ; "$"  "$"   0
>8a23	1c 8a 1c 23			MNEML   .BYTE $1C,$8A,$1C,$23   ; BRK PHP BPL CLC
>8a27	5d 8b 1b a1			        .BYTE $5D,$8B,$1B,$A1   ; JSR PLP BMI SEC
>8a2b	9d 8a 1d 23			        .BYTE $9D,$8A,$1D,$23   ; RTI PHA BVC CLI
>8a2f	9d 8b 1d a1			        .BYTE $9D,$8B,$1D,$A1   ; RTS PLA BVS SEI
>8a33	00 29 19 ae			        .BYTE $00,$29,$19,$AE   ; ??? DEY BCC TYA
>8a37	69 a8 19 23			        .BYTE $69,$A8,$19,$23   ; LDY TAY BCS CLV
>8a3b	24 53 1b 23			        .BYTE $24,$53,$1B,$23   ; CPY INY BNE CLD
>8a3f	24 53 19 a1			        .BYTE $24,$53,$19,$A1   ; CPX INX BEQ SED
>8a43	00 1a 5b 5b			        .BYTE $00,$1A,$5B,$5B   ; ??? BIT JMP JMP
>8a47	a5 69 24 24			        .BYTE $A5,$69,$24,$24   ; STY LDY CPY CPX
>8a4b	ae ae a8 ad			        .BYTE $AE,$AE,$A8,$AD   ; TXA TXS TAX TSX
>8a4f	29 00 7c 00			        .BYTE $29,$00,$7C,$00   ; DEX ??? NOP ???
>8a53	15 9c 6d 9c			        .BYTE $15,$9C,$6D,$9C   ; ASL ROL LSR ROR
>8a57	a5 69 29 53			        .BYTE $A5,$69,$29,$53   ; STX LDX DEC INC
>8a5b	84 13 34 11			        .BYTE $84,$13,$34,$11   ; ORA AND EOR ADC
>8a5f	a5 69 23 a0			        .BYTE $A5,$69,$23,$A0   ; STA LDA CMP SBC
>8a63	d8 62 5a 48			MNEMR   .BYTE $D8,$62,$5A,$48   ; BRK PHP BPL CLC
>8a67	26 62 94 88			        .BYTE $26,$62,$94,$88   ; JSR PLP BMI SEC
>8a6b	54 44 c8 54			        .BYTE $54,$44,$C8,$54   ; RTI PHA BVC CLI
>8a6f	68 44 e8 94			        .BYTE $68,$44,$E8,$94   ; RTS PLA BVS SEI
>8a73	00 b4 08 84			        .BYTE $00,$B4,$08,$84   ; ??? DEY BCC TYA
>8a77	74 b4 28 6e			        .BYTE $74,$B4,$28,$6E   ; LDY TAY BCS CLV
>8a7b	74 f4 cc 4a			        .BYTE $74,$F4,$CC,$4A   ; CPY INY BNE CLD
>8a7f	72 f2 a4 8a			        .BYTE $72,$F2,$A4,$8A   ; CPX INX BEQ SED
>8a83	00 aa a2 a2			        .BYTE $00,$AA,$A2,$A2   ; ??? BIT JMP JMP
>8a87	74 74 74 72			        .BYTE $74,$74,$74,$72   ; STY LDY CPY CPX
>8a8b	44 68 b2 32			        .BYTE $44,$68,$B2,$32   ; TXA TXS TAX TSX
>8a8f	b2 00 22 00			        .BYTE $B2,$00,$22,$00   ; DEX ??? NOP ???
>8a93	1a 1a 26 26			        .BYTE $1A,$1A,$26,$26   ; ASL ROL LSR ROR
>8a97	72 72 88 c8			        .BYTE $72,$72,$88,$C8   ; STX LDX DEC INC
>8a9b	c4 ca 26 48			        .BYTE $C4,$CA,$26,$48   ; ORA AND EOR ADC
>8a9f	44 44 a2 c8			        .BYTE $44,$44,$A2,$C8   ; STA LDA CMP SBC
>8aa3	0d 20 20 20			        .BYTE $0D,$20,$20,$20
>8aa7	41 43 44 46 47 48 4a 4d		KEYW    .TEXT "ACDFGHJMRTX@.>;"
>8aaf	52 54 58 40 2e 3e 3b
>8ab6	24 2b 26 25 4c 53 56		HIKEY   .TEXT "$+&%LSV"
=$8abd					KEYTOP  =*
>8abd	43 83 9b 81 d0 84 1e 83		KADDR   .WORD ASSEM-1,COMPAR-1,DISASS-1,FILL-1
>8ac5	26 81 1f 82 44 81 b9 80		        .WORD GOTO-1,HUNT-1,JSUB-1,DSPLYM-1
>8acd	3e 80 9e 81 b6 80 77 88		        .WORD DSPLYR-1,TRANS-1,EXIT-1,DSTAT-1
>8ad5	43 83 06 81 ef 80		        .WORD ASSEM-1,ALTM-1,ALTR-1
>8adb	10 0a 08 02			MODTAB  .BYTE $10,$0A,$08,02    ; modulo number systems
>8adf	04 03 03 01			LENTAB  .BYTE $04,$03,$03,$01   ; bits per digit
>8ae3	30 80				LINKAD  .WORD BREAK             ; address of brk handler
>8ae5	00 80				SUPAD   .WORD SUPER             ; address of entry point

;******  End of listing
